From 185473b8b930548daeeec1d7451fb95005d3df0f Mon Sep 17 00:00:00 2001
From: PaulPTLiu <Liu.PaulPT@inventec.com>
Date: Mon, 26 Jun 2023 15:59:15 +0800
Subject: [PATCH] [superion][Kernel] Modify JTAG driver with intel JTAG driver

Symptom/Reason:
    Sync ASD_BHS_V1.51 kernel-source and add into kernel

Root Cause:
    N/A

Solution/Change:

    jtag drivers
        - remove jtag-aspeed-internal
        - jtag
        - jtag-aspeed
Entry Test:
    N/A
---
 Documentation/ABI/testing/jtag-dev            |   23 +
 .../devicetree/bindings/jtag/aspeed-jtag.yaml |   85 +
 Documentation/index.rst                       |    1 +
 Documentation/jtag/index.rst                  |   18 +
 Documentation/jtag/jtag-summary.rst           |   47 +
 Documentation/jtag/jtagdev.rst                |  207 +++
 .../userspace-api/ioctl/ioctl-number.rst      |    2 +
 MAINTAINERS                                   |   11 +
 drivers/Makefile                              |    4 +-
 drivers/jtag/Kconfig                          |    4 +-
 drivers/jtag/Makefile                         |    2 +-
 drivers/jtag/jtag-aspeed-internal.c           | 1079 -----------
 drivers/jtag/jtag-aspeed.c                    | 1621 +++++++++++++++++
 drivers/jtag/jtag.c                           |   17 +-
 drivers/jtag/jtag.h                           |  369 ++++
 15 files changed, 2391 insertions(+), 1099 deletions(-)
 create mode 100644 Documentation/ABI/testing/jtag-dev
 create mode 100755 Documentation/devicetree/bindings/jtag/aspeed-jtag.yaml
 create mode 100644 Documentation/jtag/index.rst
 create mode 100644 Documentation/jtag/jtag-summary.rst
 create mode 100644 Documentation/jtag/jtagdev.rst
 delete mode 100644 drivers/jtag/jtag-aspeed-internal.c
 create mode 100644 drivers/jtag/jtag-aspeed.c
 create mode 100644 drivers/jtag/jtag.h

diff --git a/Documentation/ABI/testing/jtag-dev b/Documentation/ABI/testing/jtag-dev
new file mode 100644
index 000000000000..423baab18761
--- /dev/null
+++ b/Documentation/ABI/testing/jtag-dev
@@ -0,0 +1,23 @@
+What:		/dev/jtag[0-9]+
+Date:		July 2018
+KernelVersion:	4.20
+Contact:	oleksandrs@mellanox.com
+Description:
+		The misc device files /dev/jtag* are the interface
+		between JTAG master interface and userspace.
+
+		The ioctl(2)-based ABI is defined and documented in
+		[include/uapi]<linux/jtag.h>.
+
+		The following file operations are supported:
+
+		open(2)
+		Opens and allocates file descriptor.
+
+		ioctl(2)
+		Initiate various actions.
+		See the inline documentation in [include/uapi]<linux/jtag.h>
+		for descriptions of all ioctls.
+
+Users:
+		userspace tools which wants to access to JTAG bus
diff --git a/Documentation/devicetree/bindings/jtag/aspeed-jtag.yaml b/Documentation/devicetree/bindings/jtag/aspeed-jtag.yaml
new file mode 100755
index 000000000000..26faec29a5fb
--- /dev/null
+++ b/Documentation/devicetree/bindings/jtag/aspeed-jtag.yaml
@@ -0,0 +1,85 @@
+# SPDX-License-Identifier: (GPL-2.0-only OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/jtag/aspeed-jtag.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: Aspeed JTAG driver for ast2400, ast2500 and ast2600 SoC
+
+description:
+  Driver adds support of Aspeed 24/25/2600 series SOC JTAG master controller.
+  Driver implements the following jtag ops
+    freq_get
+    freq_set
+    status_get
+    status_set
+    xfer
+    mode_set
+    bitbang
+    enable
+    disable
+
+  It has been tested on Mellanox system with BMC equipped with
+  Aspeed 2520 SoC for programming CPLD devices.
+
+  It has also been tested on Intel system using Aspeed 25xx SoC
+  for JTAG communication.
+
+  Tested on Intel system using Aspeed 26xx SoC for JTAG communication.
+
+maintainers:
+  - Oleksandr Shamray <oleksandrs@mellanox.com>
+  - Jiri Pirko <jiri@mellanox.com>
+  - Ernesto Corona<ernesto.corona@intel.com>
+
+properties:
+  compatible:
+    oneOf:
+      - items:
+          - enum:
+              - aspeed,ast2400-jtag
+              - aspeed,ast2500-jtag
+              - aspeed,ast2600-jtag
+
+
+  reg:
+    items:
+      - description: JTAG Master controller register range
+
+  interrupts:
+    maxItems: 1
+
+  clocks:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - interrupts
+  - clocks
+
+examples:
+  - |
+    #include <dt-bindings/clock/aspeed-clock.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+      jtag: jtag@1e6e4000 {
+          compatible = "aspeed,ast2500-jtag";
+          reg = <0x1e6e4000 0x1c>;
+          clocks = <&syscon ASPEED_CLK_APB>;
+          resets = <&syscon ASPEED_RESET_JTAG_MASTER>;
+          interrupts = <43>;
+      };
+  - |
+    #include <dt-bindings/clock/aspeed-clock.h>
+    #include <dt-bindings/interrupt-controller/irq.h>
+
+      jtag1: jtag@1e6e4100 {
+          compatible = "aspeed,ast2600-jtag";
+          reg = <0x1e6e4100 0x40>;
+          clocks = <&syscon ASPEED_CLK_APB1>;
+          resets = <&syscon ASPEED_RESET_JTAG_MASTER2>;
+          interrupts = <GIC_SPI 53 IRQ_TYPE_LEVEL_HIGH>;
+      };
+
+...
diff --git a/Documentation/index.rst b/Documentation/index.rst
index 54ce34fd6fbd..91f4f7923359 100644
--- a/Documentation/index.rst
+++ b/Documentation/index.rst
@@ -111,6 +111,7 @@ needed).
    iio/index
    isdn/index
    infiniband/index
+   jtag/index
    leds/index
    netlabel/index
    networking/index
diff --git a/Documentation/jtag/index.rst b/Documentation/jtag/index.rst
new file mode 100644
index 000000000000..8a2761d1c17e
--- /dev/null
+++ b/Documentation/jtag/index.rst
@@ -0,0 +1,18 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+==============================
+Joint Test Action Group (JTAG)
+==============================
+
+.. toctree::
+   :maxdepth: 1
+
+   jtag-summary
+   jtagdev
+
+.. only::  subproject and html
+
+   Indices
+   =======
+
+   * :ref:`genindex`
diff --git a/Documentation/jtag/jtag-summary.rst b/Documentation/jtag/jtag-summary.rst
new file mode 100644
index 000000000000..050b16a9f801
--- /dev/null
+++ b/Documentation/jtag/jtag-summary.rst
@@ -0,0 +1,47 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+====================================
+Linux kernel JTAG support
+====================================
+
+Introduction to JTAG
+====================
+
+JTAG is an industry standard for verifying hardware. JTAG provides access to
+many logic signals of a complex integrated circuit, including the device pins.
+
+A JTAG interface is a special interface added to a chip.
+Depending on the version of JTAG, two, four, or five pins are added.
+
+The connector pins are:
+ * TDI (Test Data In)
+ * TDO (Test Data Out)
+ * TCK (Test Clock)
+ * TMS (Test Mode Select)
+ * TRST (Test Reset) optional
+
+JTAG interface is designed to have two parts - basic core driver and
+hardware specific driver. The basic driver introduces a general interface
+which is not dependent of specific hardware. It provides communication
+between user space and hardware specific driver.
+Each JTAG device is represented as a char device from (jtag0, jtag1, ...).
+Access to a JTAG device is performed through IOCTL calls.
+
+Call flow example:
+::
+
+	User: open  -> /dev/jatgX -> JTAG core driver -> JTAG hardware specific driver
+	User: ioctl -> /dev/jtagX -> JTAG core driver -> JTAG hardware specific driver
+	User: close -> /dev/jatgX -> JTAG core driver -> JTAG hardware specific driver
+
+
+THANKS TO
+---------
+Contributors to Linux-JTAG discussions include (in alphabetical order,
+by last name):
+
+- Ernesto Corona
+- Steven Filary
+- Vadim Pasternak
+- Jiri Pirko
+- Oleksandr Shamray
diff --git a/Documentation/jtag/jtagdev.rst b/Documentation/jtag/jtagdev.rst
new file mode 100644
index 000000000000..c50ed2b85a07
--- /dev/null
+++ b/Documentation/jtag/jtagdev.rst
@@ -0,0 +1,207 @@
+.. SPDX-License-Identifier: GPL-2.0
+
+==================
+JTAG userspace API
+==================
+JTAG master devices can be accessed through a character misc-device.
+
+Each JTAG master interface can be accessed by using /dev/jtagN.
+
+JTAG system calls set:
+ * SIR (Scan Instruction Register, IEEE 1149.1 Instruction Register scan);
+ * SDR (Scan Data Register, IEEE 1149.1 Data Register scan);
+ * RUNTEST (Forces the IEEE 1149.1 bus to a run state for a specified number of clocks.
+
+open(), close()
+---------------
+Open/Close  device:
+::
+
+	jtag_fd = open("/dev/jtag0", O_RDWR);
+	close(jtag_fd);
+
+ioctl()
+-------
+All access operations to JTAG devices are performed through ioctl interface.
+The IOCTL interface supports these requests:
+::
+
+	JTAG_SIOCSTATE - Force JTAG state machine to go into a TAPC state
+	JTAG_SIOCFREQ - Set JTAG TCK frequency
+	JTAG_GIOCFREQ - Get JTAG TCK frequency
+	JTAG_IOCXFER - send/receive JTAG data Xfer
+	JTAG_GIOCSTATUS - get current JTAG TAP state
+	JTAG_SIOCMODE - set JTAG mode flags.
+	JTAG_IOCBITBANG - JTAG bitbang low level control.
+
+JTAG_SIOCFREQ
+~~~~~~~~~~~~~
+Set JTAG clock speed:
+::
+
+	unsigned int jtag_fd;
+	ioctl(jtag_fd, JTAG_SIOCFREQ, &frq);
+
+JTAG_GIOCFREQ
+~~~~~~~~~~~~~
+Get JTAG clock speed:
+::
+
+	unsigned int jtag_fd;
+	ioctl(jtag_fd, JTAG_GIOCFREQ, &frq);
+
+JTAG_SIOCSTATE
+~~~~~~~~~~~~~~
+Force JTAG state machine to go into a TAPC state
+::
+
+	struct jtag_tap_state {
+		__u8	reset;
+		__u8	from;
+		__u8	endstate;
+		__u8	tck;
+	};
+
+reset: one of below options
+::
+
+	JTAG_NO_RESET - go through selected endstate from current state
+	JTAG_FORCE_RESET - go through TEST_LOGIC/RESET state before selected endstate
+
+endstate: any state listed in jtag_tapstate enum
+::
+
+	enum jtag_tapstate {
+		JTAG_STATE_TLRESET,
+		JTAG_STATE_IDLE,
+		JTAG_STATE_SELECTDR,
+		JTAG_STATE_CAPTUREDR,
+		JTAG_STATE_SHIFTDR,
+		JTAG_STATE_EXIT1DR,
+		JTAG_STATE_PAUSEDR,
+		JTAG_STATE_EXIT2DR,
+		JTAG_STATE_UPDATEDR,
+		JTAG_STATE_SELECTIR,
+		JTAG_STATE_CAPTUREIR,
+		JTAG_STATE_SHIFTIR,
+		JTAG_STATE_EXIT1IR,
+		JTAG_STATE_PAUSEIR,
+		JTAG_STATE_EXIT2IR,
+		JTAG_STATE_UPDATEIR
+	};
+
+tck: clock counter
+
+Example:
+::
+
+	struct jtag_tap_state tap_state;
+
+	tap_state.endstate = JTAG_STATE_IDLE;
+	tap_state.reset = 0;
+	tap_state.tck = data_p->tck;
+	usleep(25 * 1000);
+	ioctl(jtag_fd, JTAG_SIOCSTATE, &tap_state);
+
+JTAG_GIOCSTATUS
+~~~~~~~~~~~~~~~
+Get JTAG TAPC current machine state
+::
+
+	unsigned int jtag_fd;
+	jtag_tapstate tapstate;
+	ioctl(jtag_fd, JTAG_GIOCSTATUS, &tapstate);
+
+JTAG_IOCXFER
+~~~~~~~~~~~~
+Send SDR/SIR transaction
+::
+
+	struct jtag_xfer {
+		__u8	type;
+		__u8	direction;
+		__u8	from;
+		__u8	endstate;
+		__u32	padding;
+		__u32	length;
+		__u64	tdio;
+	};
+
+type: transfer type - JTAG_SIR_XFER/JTAG_SDR_XFER
+
+direction: xfer direction - JTAG_READ_XFER/JTAG_WRITE_XFER/JTAG_READ_WRITE_XFER
+
+from: jtag_tapstate enum representing the initial tap state of the chain before xfer.
+
+endstate: end state after transaction finish any of jtag_tapstate enum
+
+padding: padding configuration. See the following table with bitfield descriptions.
+
+===============  =========  =======  =====================================================
+Bit Field        Bit begin  Bit end  Description
+===============  =========  =======  =====================================================
+rsvd             25         31       Reserved, not used
+pad data         24         24       Value used for pre and post padding. Either 1 or 0.
+post pad count   12         23       Number of padding bits to be executed after transfer.
+pre pad count    0          11       Number of padding bit to be executed before transfer.
+===============  =========  =======  =====================================================
+
+length: xfer data length in bits
+
+tdio : xfer data array
+
+Example:
+::
+
+	struct jtag_xfer xfer;
+	static char buf[64];
+	static unsigned int buf_len = 0;
+	[...]
+	xfer.type = JTAG_SDR_XFER;
+	xfer.tdio = (__u64)buf;
+	xfer.length = buf_len;
+	xfer.from = JTAG_STATE_TLRESET;
+	xfer.endstate = JTAG_STATE_IDLE;
+
+	if (is_read)
+		xfer.direction = JTAG_READ_XFER;
+	else if (is_write)
+		xfer.direction = JTAG_WRITE_XFER;
+	else
+		xfer.direction = JTAG_READ_WRITE_XFER;
+
+	ioctl(jtag_fd, JTAG_IOCXFER, &xfer);
+
+JTAG_SIOCMODE
+~~~~~~~~~~~~~
+If hardware driver can support different running modes you can change it.
+
+Example:
+::
+
+	struct jtag_mode mode;
+	mode.feature = JTAG_XFER_MODE;
+	mode.mode = JTAG_XFER_HW_MODE;
+	ioctl(jtag_fd, JTAG_SIOCMODE, &mode);
+
+JTAG_IOCBITBANG
+~~~~~~~~~~~~~~~
+JTAG Bitbang low level operation.
+
+Example:
+::
+
+	struct tck_bitbang bitbang
+	bitbang.tms = 1;
+	bitbang.tdi = 0;
+	ioctl(jtag_fd, JTAG_IOCBITBANG, &bitbang);
+	tdo = bitbang.tdo;
+
+
+THANKS TO
+---------
+Contributors to Linux-JTAG discussions include (in alphabetical order,
+by last name):
+
+- Ernesto Corona
+- Jiri Pirko
diff --git a/Documentation/userspace-api/ioctl/ioctl-number.rst b/Documentation/userspace-api/ioctl/ioctl-number.rst
index 6655d929a351..c16d505dc443 100644
--- a/Documentation/userspace-api/ioctl/ioctl-number.rst
+++ b/Documentation/userspace-api/ioctl/ioctl-number.rst
@@ -345,6 +345,8 @@ Code  Seq#    Include File                                           Comments
                                                                      <mailto:vgo@ratio.de>
 0xB1  00-1F                                                          PPPoX
                                                                      <mailto:mostrows@styx.uwaterloo.ca>
+0xB2  00-0F  linux/jtag.h                                            JTAG driver
+                                                                     <mailto:oleksandrs@mellanox.com>
 0xB3  00     linux/mmc/ioctl.h
 0xB4  00-0F  linux/gpio.h                                            <mailto:linux-gpio@vger.kernel.org>
 0xB5  00-0F  uapi/linux/rpmsg.h                                      <mailto:linux-remoteproc@vger.kernel.org>
diff --git a/MAINTAINERS b/MAINTAINERS
index e25323549e54..03b126257619 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -10081,6 +10081,17 @@ L:	linux-serial@vger.kernel.org
 S:	Orphan
 F:	drivers/tty/serial/jsm/
 
+JTAG SUBSYSTEM
+M:	Oleksandr Shamray <oleksandrs@mellanox.com>
+M:	Vadim Pasternak <vadimp@mellanox.com>
+M	Ernesto Corona <ernesto.corona@intel.com>
+S:	Maintained
+F:	Documentation/ABI/testing/jtag-dev
+F:	Documentation/devicetree/bindings/jtag/
+F:	drivers/jtag/
+F:	include/linux/jtag.h
+F:	include/uapi/linux/jtag.h
+
 K10TEMP HARDWARE MONITORING DRIVER
 M:	Clemens Ladisch <clemens@ladisch.de>
 L:	linux-hwmon@vger.kernel.org
diff --git a/drivers/Makefile b/drivers/Makefile
index cbc9bb20983f..bdd2a1c3779a 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -187,5 +187,5 @@ obj-$(CONFIG_GNSS)		+= gnss/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
-obj-$(CONFIG_JTAG)		+= jtag/
-obj-$(CONFIG_PECI)		+= peci/
\ No newline at end of file
+obj-$(CONFIG_PECI)		+= peci/
+obj-$(CONFIG_JTAG_ASPEED)		+= jtag/
diff --git a/drivers/jtag/Kconfig b/drivers/jtag/Kconfig
index d6a1d6a8c679..2cc28615ab8c 100644
--- a/drivers/jtag/Kconfig
+++ b/drivers/jtag/Kconfig
@@ -16,8 +16,8 @@ menuconfig JTAG
 	  To compile this driver as a module, choose M here: the module will
 	  be called jtag.
 
-menuconfig JTAG_ASPEED_INTERNAL
-	tristate "Aspeed SoC JTAG controller support internal"
+menuconfig JTAG_ASPEED
+	tristate "Aspeed SoC JTAG controller support"
 	depends on JTAG && HAS_IOMEM
 	depends on ARCH_ASPEED || COMPILE_TEST
 	help
diff --git a/drivers/jtag/Makefile b/drivers/jtag/Makefile
index a5880cb48cfa..04a855e2df28 100644
--- a/drivers/jtag/Makefile
+++ b/drivers/jtag/Makefile
@@ -1,2 +1,2 @@
 obj-$(CONFIG_JTAG)		+= jtag.o
-obj-$(CONFIG_JTAG_ASPEED_INTERNAL) += jtag-aspeed-internal.o
\ No newline at end of file
+obj-$(CONFIG_JTAG_ASPEED)	+= jtag-aspeed.o
diff --git a/drivers/jtag/jtag-aspeed-internal.c b/drivers/jtag/jtag-aspeed-internal.c
deleted file mode 100644
index 02b4a60f7b4f..000000000000
--- a/drivers/jtag/jtag-aspeed-internal.c
+++ /dev/null
@@ -1,1079 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * JTAG driver for the Aspeed SoC
- *
- * Copyright (C) 2021 ASPEED Technology Inc.
- * Ryan Chen <ryan_chen@aspeedtech.com>
- *
- */
-#include <linux/poll.h>
-#include <linux/sysfs.h>
-#include <linux/clk.h>
-#include <linux/fs.h>
-#include <linux/delay.h>
-#include <linux/init.h>
-#include <linux/module.h>
-#include <linux/miscdevice.h>
-#include <linux/slab.h>
-#include <linux/sched.h>
-#include <linux/interrupt.h>
-#include <linux/jtag.h>
-#include <linux/platform_device.h>
-#include <linux/reset.h>
-#include <linux/io.h>
-#include <linux/of.h>
-#include <linux/of_device.h>
-#include <linux/uaccess.h>
-#include <uapi/linux/jtag.h>
-/******************************************************************************/
-#define ASPEED_JTAG_DATA		0x00
-#define ASPEED_JTAG_INST		0x04
-#define ASPEED_JTAG_CTRL		0x08
-#define ASPEED_JTAG_ISR			0x0C
-#define ASPEED_JTAG_SW			0x10
-#define ASPEED_JTAG_TCK			0x14
-#define ASPEED_JTAG_IDLE		0x18
-
-/* ASPEED_JTAG_CTRL - 0x08 : Engine Control */
-#define JTAG_ENG_EN			BIT(31)
-#define JTAG_ENG_OUT_EN			BIT(30)
-#define JTAG_FORCE_TMS			BIT(29)
-
-#define JTAG_IR_UPDATE			BIT(26)		//AST2500 only
-
-#define JTAG_G6_RESET_FIFO		BIT(21)		//AST2600 only
-#define JTAG_G6_CTRL_MODE		BIT(20)		//AST2600 only
-#define JTAG_G6_XFER_LEN_MASK		(0x3ff << 8)	//AST2600 only
-#define JTAG_G6_SET_XFER_LEN(x)		(x << 8)
-#define JTAG_G6_MSB_FIRST		BIT(6)		//AST2600 only
-#define JTAG_G6_TERMINATE_XFER		BIT(5)		//AST2600 only
-#define JTAG_G6_LAST_XFER		BIT(4)		//AST2600 only
-#define JTAG_G6_INST_EN			BIT(1)
-
-#define JTAG_INST_LEN_MASK		(0x3f << 20)
-#define JTAG_SET_INST_LEN(x)		(x << 20)
-#define JTAG_SET_INST_MSB		BIT(19)
-#define JTAG_TERMINATE_INST		BIT(18)
-#define JTAG_LAST_INST			BIT(17)
-#define JTAG_INST_EN			BIT(16)
-#define JTAG_DATA_LEN_MASK		(0x3f << 4)
-
-#define JTAG_DR_UPDATE			BIT(10)		//AST2500 only
-#define JTAG_DATA_LEN(x)		(x << 4)
-#define JTAG_MSB_FIRST			BIT(3)
-#define JTAG_TERMINATE_DATA		BIT(2)
-#define JTAG_LAST_DATA			BIT(1)
-#define JTAG_DATA_EN			BIT(0)
-
-/* ASPEED_JTAG_ISR	- 0x0C : INterrupt status and enable */
-#define JTAG_INST_PAUSE			BIT(19)
-#define JTAG_INST_COMPLETE		BIT(18)
-#define JTAG_DATA_PAUSE			BIT(17)
-#define JTAG_DATA_COMPLETE		BIT(16)
-
-#define JTAG_INST_PAUSE_EN		BIT(3)
-#define JTAG_INST_COMPLETE_EN		BIT(2)
-#define JTAG_DATA_PAUSE_EN		BIT(1)
-#define JTAG_DATA_COMPLETE_EN		BIT(0)
-
-/* ASPEED_JTAG_SW	- 0x10 : Software Mode and Status */
-#define JTAG_SW_MODE_EN			BIT(19)
-#define JTAG_SW_MODE_TCK		BIT(18)
-#define JTAG_SW_MODE_TMS		BIT(17)
-#define JTAG_SW_MODE_TDIO		BIT(16)
-//
-#define JTAG_STS_INST_PAUSE		BIT(2)
-#define JTAG_STS_DATA_PAUSE		BIT(1)
-#define JTAG_STS_ENG_IDLE		(0x1)
-
-/* ASPEED_JTAG_TCK	- 0x14 : TCK Control */
-#define JTAG_TCK_INVERSE		BIT(31)
-#define JTAG_TCK_DIVISOR_MASK		(0x7ff)
-#define JTAG_GET_TCK_DIVISOR(x)		(x & 0x7ff)
-
-/*  ASPEED_JTAG_IDLE - 0x18 : Ctroller set for go to IDLE */
-#define JTAG_CTRL_TRSTn_HIGH		BIT(31)
-#define JTAG_GO_IDLE			BIT(0)
-
-#define TCK_FREQ			1000000
-#define ASPEED_JTAG_MAX_PAD_SIZE	1024
-/******************************************************************************/
-#define ASPEED_JTAG_DEBUG
-
-#ifdef ASPEED_JTAG_DEBUG
-#define JTAG_DBUG(fmt, args...)                                                \
-	pr_debug("%s() " fmt, __func__, ##args)
-#else
-#define JTAG_DBUG(fmt, args...)
-#endif
-
-static char *end_status_str[] = { "tlr",   "idle",  "selDR", "capDR",
-				  "sDR",   "ex1DR", "pDR",   "ex2DR",
-				  "updDR", "selIR", "capIR", "sIR",
-				  "ex1IR", "pIR",   "ex2IR", "updIR" };
-
-struct aspeed_jtag_config {
-	u8	jtag_version;
-	u32	jtag_buff_len;
-};
-
-struct aspeed_jtag_info {
-	void __iomem			*reg_base;
-	struct device			*dev;
-	struct aspeed_jtag_config	*config;
-	enum jtag_tapstate		sts;
-	int				irq;
-	struct reset_control		*reset;
-	struct clk			*clk;
-	u32				clkin;
-	u32				tck_period;
-	u32				sw_delay;
-	u32				flag;
-	wait_queue_head_t		jtag_wq;
-	u32				mode;
-	u8 pad_data_one[ASPEED_JTAG_MAX_PAD_SIZE];
-	u8 pad_data_zero[ASPEED_JTAG_MAX_PAD_SIZE];
-};
-/******************************************************************************/
-static inline u32
-aspeed_jtag_read(struct aspeed_jtag_info *aspeed_jtag, u32 reg)
-{
-	int val;
-
-	val = readl(aspeed_jtag->reg_base + reg);
-	return val;
-}
-
-static inline void
-aspeed_jtag_write(struct aspeed_jtag_info *aspeed_jtag, u32 val, u32 reg)
-{
-	writel(val, aspeed_jtag->reg_base + reg);
-}
-
-/******************************************************************************/
-static int aspeed_jtag_set_freq(struct jtag *jtag, u32 freq)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-	u32 div;
-
-	/* SW mode frequency setting */
-	aspeed_jtag->sw_delay = DIV_ROUND_UP(NSEC_PER_SEC, freq);
-	/*
-	 * HW mode frequency setting
-	 * AST2600: TCK period = Period of HCLK * (JTAG14[10:0] + 1)
-	 * AST2500: TCK period = Period of PCLK * (JTAG14[10:0] + 1) * 2
-	 */
-	if (aspeed_jtag->config->jtag_version == 6)
-		div = DIV_ROUND_UP(aspeed_jtag->clkin, freq) - 1;
-	else
-		div = DIV_ROUND_UP(aspeed_jtag->clkin, freq * 2) - 1;
-	if (div > JTAG_TCK_DIVISOR_MASK) {
-		pr_warn("The actual frequency will faster than required\n");
-		div = JTAG_TCK_DIVISOR_MASK;
-	}
-	/*
-	 * HW constraint:
-	 * AST2600 minimal TCK divisor = 7
-	 * AST2500 minimal TCK divisor = 1
-	 */
-	if (aspeed_jtag->config->jtag_version == 6) {
-		if (div < 7)
-			div = 7;
-		aspeed_jtag->tck_period = DIV_ROUND_UP_ULL(
-			(u64)NSEC_PER_SEC * (div + 1), aspeed_jtag->clkin);
-	} else if (aspeed_jtag->config->jtag_version == 0) {
-		if (div < 1)
-			div = 1;
-		aspeed_jtag->tck_period = DIV_ROUND_UP_ULL(
-			(u64)NSEC_PER_SEC * (div + 1) << 2, aspeed_jtag->clkin);
-	}
-	/*
-	 * At ast2500: Change clock divider may cause hardware logic confusion.
-	 * Enable software mode to assert the jtag hw logical before change
-	 * clock divider.
-	 */
-	if (aspeed_jtag->config->jtag_version == 0)
-		aspeed_jtag_write(aspeed_jtag,
-				  JTAG_SW_MODE_EN |
-					  aspeed_jtag_read(aspeed_jtag,
-							   ASPEED_JTAG_SW),
-				  ASPEED_JTAG_SW);
-	aspeed_jtag_write(aspeed_jtag,
-			  ((aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK) &
-			    ~JTAG_TCK_DIVISOR_MASK) |
-			   div),
-			  ASPEED_JTAG_TCK);
-	if (aspeed_jtag->config->jtag_version == 0) {
-		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
-		aspeed_jtag->sts = JTAG_STATE_IDLE;
-	}
-	JTAG_DBUG("Operation freq = %d / %d\n", aspeed_jtag->clkin, div + 1);
-	return 0;
-}
-
-static int aspeed_jtag_get_freq(struct jtag *jtag, u32 *freq)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-
-	if (aspeed_jtag->config->jtag_version == 6) {
-		/* TCK period = Period of HCLK * (JTAG14[10:0] + 1) */
-		*freq = aspeed_jtag->clkin /
-		       (JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(
-				aspeed_jtag, ASPEED_JTAG_TCK)) + 1);
-	} else if (aspeed_jtag->config->jtag_version == 0) {
-		/* TCK period = Period of PCLK * (JTAG14[10:0] + 1) * 2 */
-		*freq = (aspeed_jtag->clkin /
-			(JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(
-				 aspeed_jtag, ASPEED_JTAG_TCK)) + 1)) >> 1;
-	} else {
-		/* unknown jtag version */
-		*freq = 0;
-	}
-	return 0;
-}
-/******************************************************************************/
-static u8 TCK_Cycle(struct aspeed_jtag_info *aspeed_jtag, u8 TMS, u8 TDI)
-{
-	u8 tdo;
-
-	/* IEEE 1149.1
-	 * TMS & TDI shall be sampled by the test logic on the rising edge
-	 * test logic shall change TDO on the falling edge
-	 */
-	// TCK = 0
-	aspeed_jtag_write(aspeed_jtag,
-			  JTAG_SW_MODE_EN | (TMS * JTAG_SW_MODE_TMS) |
-				  (TDI * JTAG_SW_MODE_TDIO),
-			  ASPEED_JTAG_SW);
-
-	/* Target device have their operating frequency*/
-	ndelay(aspeed_jtag->sw_delay);
-
-	// TCK = 1
-	aspeed_jtag_write(aspeed_jtag,
-			  JTAG_SW_MODE_EN | JTAG_SW_MODE_TCK |
-				  (TMS * JTAG_SW_MODE_TMS) |
-				  (TDI * JTAG_SW_MODE_TDIO),
-			  ASPEED_JTAG_SW);
-
-	ndelay(aspeed_jtag->sw_delay);
-	/* Sampled TDI(slave, master's TDO) on the rising edge */
-	if (aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) & JTAG_SW_MODE_TDIO)
-		tdo = 1;
-	else
-		tdo = 0;
-
-	return tdo;
-}
-
-static int aspeed_jtag_sw_set_tap_state(struct aspeed_jtag_info *aspeed_jtag,
-				      enum jtag_tapstate endstate)
-{
-	int i = 0;
-	enum jtag_tapstate from, to;
-
-	from = aspeed_jtag->sts;
-	to = endstate;
-	/* Send 8 TMS high to ensure jtag tap state go to TLRESET */
-	if (endstate == JTAG_STATE_TLRESET)
-		for (i = 0; i < 8 ; i++)
-			TCK_Cycle(aspeed_jtag, ((0xff >> i) & 0x1), 0);
-	else
-		for (i = 0; i < _tms_cycle_lookup[from][to].count; i++)
-			TCK_Cycle(aspeed_jtag,
-				  ((_tms_cycle_lookup[from][to].tmsbits >> i) &
-				   0x1),
-				  0);
-	aspeed_jtag->sts = endstate;
-	return 0;
-}
-
-/******************************************************************************/
-static void aspeed_jtag_wait_instruction_pause_complete(
-	struct aspeed_jtag_info *aspeed_jtag)
-{
-	wait_event_interruptible(aspeed_jtag->jtag_wq,
-				 (aspeed_jtag->flag & JTAG_INST_PAUSE));
-	aspeed_jtag->flag &= ~JTAG_INST_PAUSE;
-}
-static void
-aspeed_jtag_wait_instruction_complete(struct aspeed_jtag_info *aspeed_jtag)
-{
-	wait_event_interruptible(aspeed_jtag->jtag_wq,
-				 (aspeed_jtag->flag & JTAG_INST_COMPLETE));
-	aspeed_jtag->flag &= ~JTAG_INST_COMPLETE;
-}
-static void
-aspeed_jtag_wait_data_pause_complete(struct aspeed_jtag_info *aspeed_jtag)
-{
-	wait_event_interruptible(aspeed_jtag->jtag_wq,
-				 (aspeed_jtag->flag & JTAG_DATA_PAUSE));
-	aspeed_jtag->flag &= ~JTAG_DATA_PAUSE;
-}
-static void aspeed_jtag_wait_data_complete(struct aspeed_jtag_info *aspeed_jtag)
-{
-	wait_event_interruptible(aspeed_jtag->jtag_wq,
-				 (aspeed_jtag->flag & JTAG_DATA_COMPLETE));
-	aspeed_jtag->flag &= ~JTAG_DATA_COMPLETE;
-}
-static int aspeed_jtag_run_to_tlr(struct aspeed_jtag_info *aspeed_jtag)
-{
-	if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
-		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
-				ASPEED_JTAG_ISR);
-	else if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
-		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
-				  ASPEED_JTAG_ISR);
-	aspeed_jtag_write(aspeed_jtag,
-			  JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_FORCE_TMS,
-			  ASPEED_JTAG_CTRL); // x TMS high + 1 TMS low
-	if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
-		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
-	else if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
-		aspeed_jtag_wait_data_complete(aspeed_jtag);
-	/* After that the fsm will go to idle state: hw constraint */
-	aspeed_jtag->sts = JTAG_STATE_IDLE;
-	return 0;
-}
-
-static int aspeed_jtag_run_to_idle(struct aspeed_jtag_info *aspeed_jtag)
-{
-	if (aspeed_jtag->sts == JTAG_STATE_IDLE) {
-		/* nothing to do */
-	} else if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
-					  ASPEED_JTAG_ISR);
-		if (aspeed_jtag->config->jtag_version == 6) {
-			aspeed_jtag_write(aspeed_jtag,
-					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						JTAG_G6_TERMINATE_XFER |
-						JTAG_DATA_EN,
-					ASPEED_JTAG_CTRL);
-		} else {
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_TERMINATE_DATA |
-						  JTAG_DATA_EN,
-					  ASPEED_JTAG_CTRL);
-		}
-		aspeed_jtag_wait_data_complete(aspeed_jtag);
-	} else if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
-					  ASPEED_JTAG_ISR);
-		if (aspeed_jtag->config->jtag_version == 6) {
-			aspeed_jtag_write(aspeed_jtag,
-					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						JTAG_G6_TERMINATE_XFER |
-						JTAG_G6_INST_EN,
-					ASPEED_JTAG_CTRL);
-		} else {
-			aspeed_jtag_write(aspeed_jtag,
-					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						JTAG_TERMINATE_INST |
-						JTAG_INST_EN,
-					ASPEED_JTAG_CTRL);
-		}
-		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
-	} else {
-		pr_err("Should not get here unless aspeed_jtag->sts error!");
-		return -EFAULT;
-	}
-	aspeed_jtag->sts = JTAG_STATE_IDLE;
-	return 0;
-}
-
-static int aspeed_jtag_hw_set_tap_state(struct aspeed_jtag_info *aspeed_jtag,
-				      enum jtag_tapstate endstate)
-{
-	int ret;
-
-	if (endstate == JTAG_STATE_TLRESET) {
-		ret = aspeed_jtag_run_to_tlr(aspeed_jtag);
-	} else if (endstate == JTAG_STATE_IDLE) {
-		ret = aspeed_jtag_run_to_idle(aspeed_jtag);
-	} else {
-		/* other stable state will auto handle by hardware */
-		return 0;
-	}
-	return ret;
-}
-
-/******************************************************************************/
-/* JTAG_reset() is to generate at leaspeed 9 TMS high and
- * 1 TMS low to force devices into Run-Test/Idle State
- */
-static int aspeed_jtag_status_set(struct jtag *jtag,
-				  struct jtag_tap_state *tapstate)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-	int ret;
-	uint32_t i;
-
-	if (tapstate->from == JTAG_STATE_CURRENT)
-		tapstate->from = aspeed_jtag->sts;
-	JTAG_DBUG("reset:%d from:%s end:%s tck:%d", tapstate->reset,
-		  end_status_str[tapstate->from],
-		  end_status_str[tapstate->endstate], tapstate->tck);
-	if (aspeed_jtag->mode == JTAG_XFER_HW_MODE) {
-		if (tapstate->reset == JTAG_FORCE_RESET)
-			aspeed_jtag_hw_set_tap_state(aspeed_jtag,
-						     JTAG_STATE_TLRESET);
-		ret = aspeed_jtag_hw_set_tap_state(aspeed_jtag,
-						   tapstate->endstate);
-		for (i = 0; i < tapstate->tck; i++)
-			ndelay(aspeed_jtag->tck_period);
-	} else {
-		if (tapstate->reset == JTAG_FORCE_RESET)
-			aspeed_jtag_sw_set_tap_state(aspeed_jtag,
-						     JTAG_STATE_TLRESET);
-		ret = aspeed_jtag_sw_set_tap_state(aspeed_jtag,
-						   tapstate->endstate);
-		if (tapstate->endstate == JTAG_STATE_TLRESET ||
-		    tapstate->endstate == JTAG_STATE_IDLE ||
-		    tapstate->endstate == JTAG_STATE_PAUSEDR ||
-		    tapstate->endstate == JTAG_STATE_PAUSEIR)
-			for (i = 0; i < tapstate->tck; i++)
-				TCK_Cycle(aspeed_jtag, 0, 0);
-	}
-	if (ret)
-		return ret;
-	return 0;
-}
-
-static int aspeed_jtag_status_get(struct jtag *jtag, u32 *status)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-
-	*status = aspeed_jtag->sts;
-	return 0;
-}
-static void aspeed_sw_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag,
-				struct jtag_xfer *xfer, u8 *xfer_data)
-{
-	unsigned int index = 0;
-	u32 shift_bits = 0;
-	u8 tdi = 0, tdo = 0, tdo_buff = 0;
-	u32 remain_xfer = xfer->length;
-
-	if (xfer->type == JTAG_SIR_XFER)
-		aspeed_jtag_sw_set_tap_state(aspeed_jtag, JTAG_STATE_SHIFTIR);
-	else
-		aspeed_jtag_sw_set_tap_state(aspeed_jtag, JTAG_STATE_SHIFTDR);
-
-	while (remain_xfer) {
-		tdi = (xfer_data[index]) >> (shift_bits % 8) & (0x1);
-		if (remain_xfer == 1 &&
-		    xfer->endstate != (xfer->type == JTAG_SIR_XFER ?
-						     JTAG_STATE_SHIFTIR :
-						     JTAG_STATE_SHIFTDR)) {
-			tdo = TCK_Cycle(aspeed_jtag, 1, tdi); // go to Exit1-XR
-			aspeed_jtag->sts = xfer->type == JTAG_SIR_XFER ?
-							 JTAG_STATE_EXIT1IR :
-							 JTAG_STATE_EXIT1DR;
-		} else
-			tdo = TCK_Cycle(aspeed_jtag, 0, tdi); // go to XRShift
-		tdo_buff |= (tdo << (shift_bits % 8));
-		shift_bits++;
-		remain_xfer--;
-		if ((shift_bits % 8) == 0) {
-			if (xfer->direction & JTAG_READ_XFER)
-				xfer_data[index] = tdo_buff;
-			tdo_buff = 0;
-			index++;
-		}
-	}
-	if (xfer->direction & JTAG_READ_XFER && (shift_bits % 8))
-		xfer_data[index] = tdo_buff;
-	aspeed_jtag_sw_set_tap_state(aspeed_jtag, xfer->endstate);
-}
-static int aspeed_hw_ir_scan(struct aspeed_jtag_info *aspeed_jtag,
-			     enum jtag_tapstate endstate, u32 shift_bits)
-{
-	if (endstate == JTAG_STATE_PAUSEIR) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_INST_PAUSE_EN,
-					  ASPEED_JTAG_ISR);
-		if (aspeed_jtag->config->jtag_version == 6) {
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_SET_XFER_LEN(shift_bits),
-				ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_SET_XFER_LEN(shift_bits) |
-					JTAG_G6_INST_EN,
-				ASPEED_JTAG_CTRL);
-		} else {
-			if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
-				aspeed_jtag_write(aspeed_jtag,
-						  JTAG_INST_PAUSE_EN |
-							  JTAG_DATA_COMPLETE_EN,
-						  ASPEED_JTAG_ISR);
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_SET_INST_LEN(shift_bits),
-					  ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_SET_INST_LEN(shift_bits) |
-					JTAG_INST_EN,
-				ASPEED_JTAG_CTRL);
-			if (aspeed_jtag->sts == JTAG_STATE_PAUSEDR)
-				aspeed_jtag_wait_data_complete(aspeed_jtag);
-		}
-		aspeed_jtag_wait_instruction_pause_complete(aspeed_jtag);
-		aspeed_jtag->sts = JTAG_STATE_PAUSEIR;
-	} else if (endstate == JTAG_STATE_IDLE) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
-					  ASPEED_JTAG_ISR);
-		if (aspeed_jtag->config->jtag_version == 6) {
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_LAST_XFER |
-					JTAG_G6_SET_XFER_LEN(shift_bits),
-				ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_LAST_XFER |
-					JTAG_G6_SET_XFER_LEN(shift_bits) |
-					JTAG_G6_INST_EN,
-				ASPEED_JTAG_CTRL);
-		} else {
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_LAST_INST |
-						  JTAG_SET_INST_LEN(shift_bits),
-					  ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_LAST_INST |
-					JTAG_SET_INST_LEN(shift_bits) |
-					JTAG_INST_EN,
-				ASPEED_JTAG_CTRL);
-		}
-		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
-		aspeed_jtag->sts = JTAG_STATE_IDLE;
-	} else {
-		pr_err("End state %d not support", endstate);
-		return -EFAULT;
-	}
-	return 0;
-}
-static int aspeed_hw_dr_scan(struct aspeed_jtag_info *aspeed_jtag,
-			     enum jtag_tapstate endstate, u32 shift_bits)
-{
-	if (endstate == JTAG_STATE_PAUSEDR) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_PAUSE_EN,
-					  ASPEED_JTAG_ISR);
-		if (aspeed_jtag->config->jtag_version == 6) {
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_SET_XFER_LEN(shift_bits),
-				ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_SET_XFER_LEN(shift_bits) |
-					JTAG_DATA_EN,
-				ASPEED_JTAG_CTRL);
-		} else {
-			if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
-				aspeed_jtag_write(aspeed_jtag,
-						  JTAG_DATA_PAUSE_EN |
-							  JTAG_INST_COMPLETE_EN,
-						  ASPEED_JTAG_ISR);
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_DATA_LEN(shift_bits),
-					  ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_DATA_LEN(shift_bits) |
-						  JTAG_DATA_EN,
-					  ASPEED_JTAG_CTRL);
-			if (aspeed_jtag->sts == JTAG_STATE_PAUSEIR)
-				aspeed_jtag_wait_instruction_complete(
-					aspeed_jtag);
-		}
-		aspeed_jtag_wait_data_pause_complete(aspeed_jtag);
-		aspeed_jtag->sts = JTAG_STATE_PAUSEDR;
-	} else if (endstate == JTAG_STATE_IDLE) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
-					  ASPEED_JTAG_ISR);
-		if (aspeed_jtag->config->jtag_version == 6) {
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_LAST_XFER |
-					JTAG_G6_SET_XFER_LEN(shift_bits),
-				ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(
-				aspeed_jtag,
-				JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-					JTAG_G6_LAST_XFER |
-					JTAG_G6_SET_XFER_LEN(shift_bits) |
-					JTAG_DATA_EN,
-				ASPEED_JTAG_CTRL);
-		} else {
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_LAST_DATA |
-						  JTAG_DATA_LEN(shift_bits),
-					  ASPEED_JTAG_CTRL);
-			aspeed_jtag_write(aspeed_jtag,
-					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_LAST_DATA |
-						  JTAG_DATA_LEN(shift_bits) |
-						  JTAG_DATA_EN,
-					  ASPEED_JTAG_CTRL);
-		}
-		aspeed_jtag_wait_data_complete(aspeed_jtag);
-		aspeed_jtag->sts = JTAG_STATE_IDLE;
-	} else {
-		pr_err("End state %d not support", endstate);
-		return -EFAULT;
-	}
-	return 0;
-}
-static void aspeed_hw_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag,
-				struct jtag_xfer *xfer, u8 *xfer_data)
-{
-	unsigned int index = 0;
-	u32 shift_bits = 0;
-	u32 remain_xfer = xfer->length;
-	int i, tmp_idx = 0;
-	u32 fifo_reg = xfer->type ? ASPEED_JTAG_DATA : ASPEED_JTAG_INST;
-	u32 *xfer_data_32 = (u32 *)xfer_data;
-	enum jtag_tapstate endstate;
-
-	/* Translate the end tap status to the stable tap status for hw mode */
-	if (xfer->endstate == JTAG_STATE_PAUSEDR ||
-	    xfer->endstate == JTAG_STATE_SHIFTDR)
-		endstate = JTAG_STATE_PAUSEDR;
-	else if (xfer->endstate == JTAG_STATE_PAUSEIR ||
-		 xfer->endstate == JTAG_STATE_SHIFTIR)
-		endstate = JTAG_STATE_PAUSEIR;
-	else
-		endstate = JTAG_STATE_IDLE;
-
-	while (remain_xfer) {
-		if (remain_xfer > aspeed_jtag->config->jtag_buff_len) {
-			shift_bits = aspeed_jtag->config->jtag_buff_len;
-			tmp_idx = shift_bits / 32;
-			for (i = 0; i < tmp_idx; i++)
-				aspeed_jtag_write(aspeed_jtag,
-						  xfer_data_32[index + i],
-						  fifo_reg);
-			/*
-			 * Add 1 tck period delay to avoid jtag hardware
-			 * transfer will get wrong fifo pointer issue.
-			 */
-			ndelay(aspeed_jtag->tck_period);
-			if (xfer->type == JTAG_SIR_XFER)
-				aspeed_hw_ir_scan(aspeed_jtag,
-						  JTAG_STATE_PAUSEIR,
-						  shift_bits);
-			else
-				aspeed_hw_dr_scan(aspeed_jtag,
-						  JTAG_STATE_PAUSEDR,
-						  shift_bits);
-		} else {
-			shift_bits = remain_xfer;
-			tmp_idx = shift_bits / 32;
-			if (shift_bits % 32)
-				tmp_idx += 1;
-			for (i = 0; i < tmp_idx; i++)
-				aspeed_jtag_write(aspeed_jtag,
-						  xfer_data_32[index + i],
-						  fifo_reg);
-			ndelay(aspeed_jtag->tck_period);
-			if (xfer->type == JTAG_SIR_XFER)
-				aspeed_hw_ir_scan(aspeed_jtag, endstate,
-						  shift_bits);
-			else
-				aspeed_hw_dr_scan(aspeed_jtag, endstate,
-						  shift_bits);
-		}
-
-		remain_xfer = remain_xfer - shift_bits;
-
-		//handle tdo data
-		if (xfer->direction & JTAG_READ_XFER) {
-			tmp_idx = shift_bits / 32;
-			if (shift_bits % 32)
-				tmp_idx += 1;
-			for (i = 0; i < tmp_idx; i++) {
-				if (shift_bits < 32)
-					xfer_data_32[index + i] =
-						aspeed_jtag_read(aspeed_jtag,
-								 fifo_reg) >>
-						(32 - shift_bits);
-				else
-					xfer_data_32[index + i] =
-						aspeed_jtag_read(aspeed_jtag,
-								 fifo_reg);
-				shift_bits -= 32;
-			}
-		}
-		index += tmp_idx;
-	}
-}
-
-static int aspeed_jtag_xfer(struct jtag *jtag, struct jtag_xfer *xfer,
-			    u8 *xfer_data)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-	union pad_config padding;
-	struct jtag_xfer pre_xfer, post_xfer;
-	struct jtag_xfer peri_xfer = {
-		.type = xfer->type,
-		.direction = xfer->direction,
-		.from = xfer->from,
-		.endstate = xfer->endstate,
-		.padding = 0,
-		.length = xfer->length,
-	};
-
-	padding.int_value = xfer->padding;
-	JTAG_DBUG(
-		"%s mode, type: %s direction: %d, END : %s, padding: (value: %d) pre_pad: %d post_pad: %d, len: %d\n",
-		aspeed_jtag->mode ? "HW" : "SW", xfer->type ? "DR" : "IR",
-		xfer->direction, end_status_str[xfer->endstate],
-		padding.pad_data, padding.pre_pad_number,
-		padding.post_pad_number, xfer->length);
-	if (padding.pre_pad_number) {
-		pre_xfer.type = xfer->type;
-		pre_xfer.direction = JTAG_WRITE_XFER;
-		pre_xfer.from = xfer->from;
-		pre_xfer.endstate =
-			xfer->type ? JTAG_STATE_PAUSEDR : JTAG_STATE_PAUSEIR;
-		pre_xfer.padding = xfer->padding;
-		pre_xfer.length = padding.pre_pad_number;
-
-		peri_xfer.from = pre_xfer.endstate;
-	}
-
-	if (padding.post_pad_number) {
-		peri_xfer.endstate =
-			xfer->type ? JTAG_STATE_PAUSEDR : JTAG_STATE_PAUSEIR;
-
-		post_xfer.type = xfer->type;
-		post_xfer.direction = JTAG_WRITE_XFER;
-		post_xfer.from = peri_xfer.endstate;
-		post_xfer.endstate = xfer->endstate;
-		post_xfer.padding = xfer->padding;
-		post_xfer.length = padding.post_pad_number;
-	}
-	if (padding.pre_pad_number) {
-		if (aspeed_jtag->mode == JTAG_XFER_HW_MODE)
-			aspeed_hw_jtag_xfer(aspeed_jtag, &pre_xfer,
-					    padding.pad_data ?
-							  aspeed_jtag->pad_data_one :
-							  aspeed_jtag->pad_data_zero);
-		else
-			aspeed_sw_jtag_xfer(aspeed_jtag, &pre_xfer,
-					    padding.pad_data ?
-							  aspeed_jtag->pad_data_one :
-							  aspeed_jtag->pad_data_zero);
-	}
-
-	if (aspeed_jtag->mode == JTAG_XFER_HW_MODE)
-		aspeed_hw_jtag_xfer(aspeed_jtag, &peri_xfer, xfer_data);
-	else
-		aspeed_sw_jtag_xfer(aspeed_jtag, &peri_xfer, xfer_data);
-
-	if (padding.post_pad_number) {
-		if (aspeed_jtag->mode == JTAG_XFER_HW_MODE)
-			aspeed_hw_jtag_xfer(aspeed_jtag, &post_xfer,
-					    padding.pad_data ?
-							  aspeed_jtag->pad_data_one :
-							  aspeed_jtag->pad_data_zero);
-		else
-			aspeed_sw_jtag_xfer(aspeed_jtag, &post_xfer,
-					    padding.pad_data ?
-							  aspeed_jtag->pad_data_one :
-							  aspeed_jtag->pad_data_zero);
-	}
-
-	return 0;
-}
-
-static irqreturn_t aspeed_jtag_isr(int this_irq, void *dev_id)
-{
-	u32 status;
-	struct aspeed_jtag_info *aspeed_jtag = dev_id;
-
-	status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR);
-
-	if (status & JTAG_INST_PAUSE) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_INST_PAUSE | (status & 0xf),
-				  ASPEED_JTAG_ISR);
-		aspeed_jtag->flag |= JTAG_INST_PAUSE;
-	}
-
-	if (status & JTAG_INST_COMPLETE) {
-		aspeed_jtag_write(aspeed_jtag,
-				  JTAG_INST_COMPLETE | (status & 0xf),
-				  ASPEED_JTAG_ISR);
-		aspeed_jtag->flag |= JTAG_INST_COMPLETE;
-	}
-
-	if (status & JTAG_DATA_PAUSE) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_PAUSE | (status & 0xf),
-				  ASPEED_JTAG_ISR);
-		aspeed_jtag->flag |= JTAG_DATA_PAUSE;
-	}
-
-	if (status & JTAG_DATA_COMPLETE) {
-		aspeed_jtag_write(aspeed_jtag,
-				  JTAG_DATA_COMPLETE | (status & 0xf),
-				  ASPEED_JTAG_ISR);
-		aspeed_jtag->flag |= JTAG_DATA_COMPLETE;
-	}
-
-	if (aspeed_jtag->flag) {
-		wake_up_interruptible(&aspeed_jtag->jtag_wq);
-		return IRQ_HANDLED;
-	}
-	pr_err("TODO Check JTAG's interrupt %x\n",
-		aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR));
-	return IRQ_NONE;
-}
-
-
-static struct aspeed_jtag_config jtag_config = {
-	.jtag_version = 0,
-	.jtag_buff_len = 32,
-};
-
-static struct aspeed_jtag_config jtag_g6_config = {
-	.jtag_version = 6,
-	.jtag_buff_len = 32,
-};
-
-static const struct of_device_id aspeed_jtag_of_matches[] = {
-	{
-		.compatible = "aspeed,ast2400-jtag",
-		.data = &jtag_config,
-	},
-	{
-		.compatible = "aspeed,ast2500-jtag",
-		.data = &jtag_config,
-	},
-	{
-		.compatible = "aspeed,ast2600-jtag",
-		.data = &jtag_g6_config,
-	},
-	{},
-};
-MODULE_DEVICE_TABLE(of, aspeed_jtag_of_matches);
-
-static int aspeed_jtag_bitbang(struct jtag *jtag,
-			       struct bitbang_packet *bitbang,
-			       struct tck_bitbang *bitbang_data)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-	int i = 0;
-
-	for (i = 0; i < bitbang->length; i++) {
-		bitbang_data[i].tdo =
-			TCK_Cycle(aspeed_jtag, bitbang_data[i].tms,
-					      bitbang_data[i].tdi);
-	}
-	if (aspeed_jtag->mode == JTAG_XFER_HW_MODE)
-		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
-
-	return 0;
-}
-
-static inline void aspeed_jtag_xfer_mode_set(struct aspeed_jtag_info *aspeed_jtag, u32 mode)
-{
-	if (mode == JTAG_XFER_HW_MODE)
-		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
-	aspeed_jtag->mode = mode;
-}
-
-static int aspeed_jtag_mode_set(struct jtag *jtag, struct jtag_mode *jtag_mode)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-
-	switch (jtag_mode->feature) {
-	case JTAG_XFER_MODE:
-		aspeed_jtag_xfer_mode_set(aspeed_jtag, jtag_mode->mode);
-		break;
-	case JTAG_CONTROL_MODE:
-		return -ENOTSUPP;
-	default:
-		return -EINVAL;
-	}
-	return 0;
-}
-
-static int aspeed_jtag_trst_set(struct jtag *jtag, u32 active)
-{
-	struct aspeed_jtag_info *aspeed_jtag = jtag_priv(jtag);
-
-	aspeed_jtag_write(aspeed_jtag, active ? 0 : JTAG_CTRL_TRSTn_HIGH,
-			  ASPEED_JTAG_IDLE);
-	return 0;
-}
-
-static int aspeed_jtag_enable(struct jtag *jtag)
-{
-	return 0;
-}
-
-static int aspeed_jtag_disable(struct jtag *jtag)
-{
-	return 0;
-}
-
-static const struct jtag_ops aspeed_jtag_ops = {
-	.freq_get = aspeed_jtag_get_freq,
-	.freq_set = aspeed_jtag_set_freq,
-	.status_get = aspeed_jtag_status_get,
-	.status_set = aspeed_jtag_status_set,
-	.xfer = aspeed_jtag_xfer,
-	.mode_set = aspeed_jtag_mode_set,
-	.trst_set = aspeed_jtag_trst_set,
-	.bitbang = aspeed_jtag_bitbang,
-	.enable = aspeed_jtag_enable,
-	.disable = aspeed_jtag_disable,
-};
-
-static int aspeed_jtag_probe(struct platform_device *pdev)
-{
-	struct aspeed_jtag_info *aspeed_jtag;
-	struct jtag *jtag;
-	const struct of_device_id *jtag_dev_id;
-	struct resource *res;
-	int ret = 0;
-
-	jtag = jtag_alloc(&pdev->dev, sizeof(*aspeed_jtag),
-			  &aspeed_jtag_ops);
-	if (!jtag)
-		return -ENOMEM;
-
-	platform_set_drvdata(pdev, jtag);
-	aspeed_jtag = jtag_priv(jtag);
-	aspeed_jtag->dev = &pdev->dev;
-
-	jtag_dev_id = of_match_device(aspeed_jtag_of_matches, &pdev->dev);
-	if (!jtag_dev_id)
-		return -EINVAL;
-
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (res == NULL) {
-		dev_err(&pdev->dev, "cannot get IORESOURCE_MEM\n");
-		ret = -ENOENT;
-		goto out;
-	}
-
-	aspeed_jtag->reg_base = devm_ioremap_resource(&pdev->dev, res);
-	if (!aspeed_jtag->reg_base) {
-		ret = -EIO;
-		goto out;
-	}
-
-	aspeed_jtag->irq = platform_get_irq(pdev, 0);
-	if (aspeed_jtag->irq < 0) {
-		dev_err(&pdev->dev, "no irq specified\n");
-		ret = -ENOENT;
-		goto out;
-	}
-	aspeed_jtag->reset =
-		devm_reset_control_get_exclusive(&pdev->dev, NULL);
-	if (IS_ERR(aspeed_jtag->reset)) {
-		dev_err(&pdev->dev, "can't get jtag reset\n");
-		return PTR_ERR(aspeed_jtag->reset);
-	}
-
-	aspeed_jtag->clk = devm_clk_get(&pdev->dev, NULL);
-	if (IS_ERR(aspeed_jtag->clk)) {
-		dev_err(&pdev->dev, "no clock defined\n");
-		return -ENODEV;
-	}
-
-	aspeed_jtag->clkin = clk_get_rate(aspeed_jtag->clk);
-	dev_dbg(&pdev->dev, "aspeed_jtag->clkin %d\n", aspeed_jtag->clkin);
-
-	aspeed_jtag->config = (struct aspeed_jtag_config *)jtag_dev_id->data;
-	// SCU init
-	reset_control_assert(aspeed_jtag->reset);
-	udelay(3);
-	reset_control_deassert(aspeed_jtag->reset);
-
-	ret = devm_request_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag_isr,
-			       0, dev_name(&pdev->dev), aspeed_jtag);
-	if (ret) {
-		dev_dbg(&pdev->dev, "JTAG Unable to get IRQ");
-		goto out;
-	}
-
-	// clear interrupt
-	aspeed_jtag_write(aspeed_jtag,
-			  JTAG_INST_PAUSE | JTAG_INST_COMPLETE |
-			  JTAG_DATA_PAUSE | JTAG_DATA_COMPLETE,
-			  ASPEED_JTAG_ISR);
-
-	aspeed_jtag_xfer_mode_set(aspeed_jtag, JTAG_XFER_HW_MODE);
-	aspeed_jtag->flag = 0;
-	aspeed_jtag->sts = JTAG_STATE_IDLE;
-	init_waitqueue_head(&aspeed_jtag->jtag_wq);
-
-	aspeed_jtag_set_freq(jtag, TCK_FREQ);
-	/* Enable jtag clock */
-	aspeed_jtag_write(aspeed_jtag, JTAG_ENG_OUT_EN, ASPEED_JTAG_CTRL);
-
-	/* Initialize JTAG core structure*/
-	ret = devm_jtag_register(aspeed_jtag->dev, jtag);
-	if (ret)
-		goto out;
-
-	memset(aspeed_jtag->pad_data_one, ~0,
-	       sizeof(aspeed_jtag->pad_data_one));
-	memset(aspeed_jtag->pad_data_zero, 0,
-	       sizeof(aspeed_jtag->pad_data_zero));
-
-	dev_info(&pdev->dev, "aspeed_jtag: driver successfully loaded.\n");
-
-	return 0;
-
-out:
-	reset_control_assert(aspeed_jtag->reset);
-	jtag_free(jtag);
-	dev_warn(&pdev->dev, "aspeed_jtag: driver init failed (ret=%d)!\n",
-		 ret);
-	return ret;
-}
-
-static int aspeed_jtag_remove(struct platform_device *pdev)
-{
-	struct jtag *jtag = platform_get_drvdata(pdev);
-	struct aspeed_jtag_info *aspeed_jtag;
-
-	aspeed_jtag = jtag_priv(jtag);
-	reset_control_assert(aspeed_jtag->reset);
-	jtag_free(jtag);
-	return 0;
-}
-
-static struct platform_driver aspeed_jtag_driver = {
-	.probe		= aspeed_jtag_probe,
-	.remove		= aspeed_jtag_remove,
-	.driver		= {
-		.name	= "aspeed-jtag",
-		.of_match_table = aspeed_jtag_of_matches,
-	},
-};
-
-module_platform_driver(aspeed_jtag_driver);
-
-MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
-MODULE_DESCRIPTION("AST JTAG LIB Driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/jtag/jtag-aspeed.c b/drivers/jtag/jtag-aspeed.c
new file mode 100644
index 000000000000..d14f17abb0db
--- /dev/null
+++ b/drivers/jtag/jtag-aspeed.c
@@ -0,0 +1,1621 @@
+// SPDX-License-Identifier: GPL-2.0
+// Copyright (c) 2018 Mellanox Technologies. All rights reserved.
+// Copyright (c) 2018 Oleksandr Shamray <oleksandrs@mellanox.com>
+// Copyright (c) 2019 Intel Corporation
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/interrupt.h>
+#include <linux/jtag.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/delay.h>
+#include <uapi/linux/jtag.h>
+
+#define ASPEED_JTAG_DATA		0x00
+#define ASPEED_JTAG_INST		0x04
+#define ASPEED_JTAG_CTRL		0x08
+#define ASPEED_JTAG_ISR		0x0C
+#define ASPEED_JTAG_SW			0x10
+#define ASPEED_JTAG_TCK		0x14
+#define ASPEED_JTAG_EC			0x18
+
+#define ASPEED_JTAG_DATA_MSB			0x01
+#define ASPEED_JTAG_DATA_CHUNK_SIZE		0x20
+#define ASPEED_JTAG_HW2_DATA_CHUNK_SIZE	512
+
+/* ASPEED_JTAG_CTRL: Engine Control 24xx and 25xx series*/
+#define ASPEED_JTAG_CTL_ENG_EN		BIT(31)
+#define ASPEED_JTAG_CTL_ENG_OUT_EN	BIT(30)
+#define ASPEED_JTAG_CTL_FORCE_TMS	BIT(29)
+#define ASPEED_JTAG_CTL_IR_UPDATE	BIT(26)
+#define ASPEED_JTAG_CTL_INST_LEN(x)	((x) << 20)
+#define ASPEED_JTAG_CTL_LASPEED_INST	BIT(17)
+#define ASPEED_JTAG_CTL_INST_EN	BIT(16)
+#define ASPEED_JTAG_CTL_DR_UPDATE	BIT(10)
+#define ASPEED_JTAG_CTL_DATA_LEN(x)	((x) << 4)
+#define ASPEED_JTAG_CTL_LASPEED_DATA	BIT(1)
+#define ASPEED_JTAG_CTL_DATA_EN	BIT(0)
+
+/* ASPEED_JTAG_CTRL: Engine Control 26xx series*/
+#define ASPEED_JTAG_CTL_26XX_RESET_FIFO	BIT(21)
+#define ASPEED_JTAG_CTL_26XX_FIFO_MODE_CTRL	BIT(20)
+#define ASPEED_JTAG_CTL_26XX_TRANS_LEN(x)	((x) << 8)
+#define ASPEED_JTAG_CTL_26XX_TRANS_MASK	GENMASK(17, 8)
+#define ASPEED_JTAG_CTL_26XX_MSB_FIRST		BIT(6)
+#define ASPEED_JTAG_CTL_26XX_TERM_TRANS	BIT(5)
+#define ASPEED_JTAG_CTL_26XX_LASPEED_TRANS	BIT(4)
+#define ASPEED_JTAG_CTL_26XX_INST_EN		BIT(1)
+
+/* ASPEED_JTAG_ISR : Interrupt status and enable */
+#define ASPEED_JTAG_ISR_INST_PAUSE		BIT(19)
+#define ASPEED_JTAG_ISR_INST_COMPLETE		BIT(18)
+#define ASPEED_JTAG_ISR_DATA_PAUSE		BIT(17)
+#define ASPEED_JTAG_ISR_DATA_COMPLETE		BIT(16)
+#define ASPEED_JTAG_ISR_INST_PAUSE_EN		BIT(3)
+#define ASPEED_JTAG_ISR_INST_COMPLETE_EN	BIT(2)
+#define ASPEED_JTAG_ISR_DATA_PAUSE_EN		BIT(1)
+#define ASPEED_JTAG_ISR_DATA_COMPLETE_EN	BIT(0)
+#define ASPEED_JTAG_ISR_INT_EN_MASK		GENMASK(3, 0)
+#define ASPEED_JTAG_ISR_INT_MASK		GENMASK(19, 16)
+
+/* ASPEED_JTAG_SW : Software Mode and Status */
+#define ASPEED_JTAG_SW_MODE_EN			BIT(19)
+#define ASPEED_JTAG_SW_MODE_TCK		BIT(18)
+#define ASPEED_JTAG_SW_MODE_TMS		BIT(17)
+#define ASPEED_JTAG_SW_MODE_TDIO		BIT(16)
+
+/* ASPEED_JTAG_TCK : TCK Control */
+#define ASPEED_JTAG_TCK_DIVISOR_MASK	GENMASK(10, 0)
+#define ASPEED_JTAG_TCK_GET_DIV(x)	((x) & ASPEED_JTAG_TCK_DIVISOR_MASK)
+
+/* ASPEED_JTAG_EC : Controller set for go to IDLE */
+#define ASPEED_JTAG_EC_GO_IDLE		BIT(0)
+#define ASPEED_JTAG_EC_TRST		BIT(31)
+
+#define ASPEED_JTAG_IOUT_LEN(len) \
+	(ASPEED_JTAG_CTL_ENG_EN | \
+	 ASPEED_JTAG_CTL_ENG_OUT_EN | \
+	 ASPEED_JTAG_CTL_INST_LEN(len))
+
+#define ASPEED_JTAG_DOUT_LEN(len) \
+	(ASPEED_JTAG_CTL_ENG_EN | \
+	 ASPEED_JTAG_CTL_ENG_OUT_EN | \
+	 ASPEED_JTAG_CTL_DATA_LEN(len))
+
+#define ASPEED_JTAG_TRANS_LEN(len) \
+	(ASPEED_JTAG_CTL_ENG_EN | \
+	 ASPEED_JTAG_CTL_ENG_OUT_EN | \
+	 ASPEED_JTAG_CTL_26XX_TRANS_LEN(len))
+
+#define ASPEED_JTAG_SW_TDIO (ASPEED_JTAG_SW_MODE_EN | ASPEED_JTAG_SW_MODE_TDIO)
+
+#define ASPEED_JTAG_GET_TDI(direction, byte) \
+	(((direction) & JTAG_WRITE_XFER) ? byte : UINT_MAX)
+
+#define ASPEED_JTAG_TCK_WAIT		10
+#define ASPEED_JTAG_RESET_CNTR		10
+#define WAIT_ITERATIONS		300
+
+/* Use this macro to switch between HW mode 1(comment out) and 2(defined)  */
+#define ASPEED_JTAG_HW_MODE_2_ENABLE	1
+
+/* ASPEED JTAG HW MODE 2 (Only supported in AST26xx series) */
+#define ASPEED_JTAG_SHDATA		0x20
+#define ASPEED_JTAG_SHINST		0x24
+#define ASPEED_JTAG_PADCTRL0		0x28
+#define ASPEED_JTAG_PADCTRL1		0x2C
+#define ASPEED_JTAG_SHCTRL		0x30
+#define ASPEED_JTAG_GBLCTRL		0x34
+#define ASPEED_JTAG_INTCTRL		0x38
+#define ASPEED_JTAG_STAT		0x3C
+
+/* ASPEED_JTAG_PADCTRLx : Padding control 0 and 1 */
+#define ASPEED_JTAG_PADCTRL_PAD_DATA	BIT(24)
+#define ASPEED_JTAG_PADCTRL_POSTPAD(x)	(((x) & GENMASK(8, 0)) << 12)
+#define ASPEED_JTAG_PADCTRL_PREPAD(x)	(((x) & GENMASK(8, 0)) << 0)
+
+/* ASPEED_JTAG_SHCTRL: Shift Control */
+#define ASPEED_JTAG_SHCTRL_FRUN_TCK_EN	BIT(31)
+#define ASPEED_JTAG_SHCTRL_STSHIFT_EN	BIT(30)
+#define ASPEED_JTAG_SHCTRL_TMS(x)	(((x) & GENMASK(13, 0)) << 16)
+#define ASPEED_JTAG_SHCTRL_POST_TMS(x)	(((x) & GENMASK(3, 0)) << 13)
+#define ASPEED_JTAG_SHCTRL_PRE_TMS(x)	(((x) & GENMASK(3, 0)) << 10)
+#define ASPEED_JTAG_SHCTRL_PAD_SEL0	(0)
+#define ASPEED_JTAG_SHCTRL_PAD_SEL1	BIT(9)
+#define ASPEED_JTAG_SHCTRL_END_SHIFT	BIT(8)
+#define ASPEED_JTAG_SHCTRL_START_SHIFT	BIT(7)
+#define ASPEED_JTAG_SHCTRL_LWRDT_SHIFT(x) ((x) & GENMASK(6, 0))
+
+#define ASPEED_JTAG_END_SHIFT_DISABLED	0
+
+/* ASPEED_JTAG_GBLCTRL : Global Control */
+#define ASPEED_JTAG_GBLCTRL_ENG_MODE_EN	BIT(31)
+#define ASPEED_JTAG_GBLCTRL_ENG_OUT_EN	BIT(30)
+#define ASPEED_JTAG_GBLCTRL_FORCE_TMS	BIT(29)
+#define ASPEED_JTAG_GBLCTRL_SHIFT_COMPLETE  BIT(28)
+#define ASPEED_JTAG_GBLCTRL_RESET_FIFO	BIT(25)
+#define ASPEED_JTAG_GBLCTRL_FIFO_CTRL_MODE	BIT(24)
+#define ASPEED_JTAG_GBLCTRL_UPDT_SHIFT(x)	(((x) & GENMASK(9, 7)) << 13)
+#define ASPEED_JTAG_GBLCTRL_STSHIFT(x)	(((x) & GENMASK(0, 0)) << 16)
+#define ASPEED_JTAG_GBLCTRL_TRST	BIT(15)
+#define ASPEED_JTAG_CLK_DIVISOR_MASK	GENMASK(11, 0)
+#define ASPEED_JTAG_CLK_GET_DIV(x)	((x) & ASPEED_JTAG_CLK_DIVISOR_MASK)
+
+/* ASPEED_JTAG_INTCTRL: Interrupt Control */
+#define ASPEED_JTAG_INTCTRL_SHCPL_IRQ_EN BIT(16)
+#define ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT BIT(0)
+
+/* ASPEED_JTAG_STAT: JTAG HW mode 2 status */
+#define ASPEED_JTAG_STAT_ENG_IDLE	BIT(0)
+
+#define ASPEED_JTAG_MAX_PAD_SIZE	512
+
+/* Use this macro to set us delay to WA the intensive R/W FIFO usage issue */
+#define AST26XX_FIFO_UDELAY		2
+
+/* Use this macro to set us delay for JTAG Master Controller to be programmed */
+#define AST26XX_JTAG_CTRL_UDELAY	2
+
+/*#define USE_INTERRUPTS*/
+#define DEBUG_JTAG
+
+static const char * const regnames[] = {
+	[ASPEED_JTAG_DATA] = "ASPEED_JTAG_DATA",
+	[ASPEED_JTAG_INST] = "ASPEED_JTAG_INST",
+	[ASPEED_JTAG_CTRL] = "ASPEED_JTAG_CTRL",
+	[ASPEED_JTAG_ISR]  = "ASPEED_JTAG_ISR",
+	[ASPEED_JTAG_SW]   = "ASPEED_JTAG_SW",
+	[ASPEED_JTAG_TCK]  = "ASPEED_JTAG_TCK",
+	[ASPEED_JTAG_EC]   = "ASPEED_JTAG_EC",
+	[ASPEED_JTAG_SHDATA]  = "ASPEED_JTAG_SHDATA",
+	[ASPEED_JTAG_SHINST]  = "ASPEED_JTAG_SHINST",
+	[ASPEED_JTAG_PADCTRL0] = "ASPEED_JTAG_PADCTRL0",
+	[ASPEED_JTAG_PADCTRL1] = "ASPEED_JTAG_PADCTRL1",
+	[ASPEED_JTAG_SHCTRL]   = "ASPEED_JTAG_SHCTRL",
+	[ASPEED_JTAG_GBLCTRL]  = "ASPEED_JTAG_GBLCTRL",
+	[ASPEED_JTAG_INTCTRL]  = "ASPEED_JTAG_INTCTRL",
+	[ASPEED_JTAG_STAT]     = "ASPEED_JTAG_STAT",
+};
+
+#define ASPEED_JTAG_NAME		"jtag-aspeed"
+
+struct aspeed_jtag {
+	void __iomem			*reg_base;
+	struct device			*dev;
+	struct clk			*pclk;
+	enum jtag_tapstate		status;
+	int				irq;
+	struct reset_control		*rst;
+	u32				flag;
+	wait_queue_head_t		jtag_wq;
+	u32				mode;
+	enum jtag_tapstate		current_state;
+	const struct jtag_low_level_functions *llops;
+	u32 pad_data_one[ASPEED_JTAG_MAX_PAD_SIZE / 32];
+	u32 pad_data_zero[ASPEED_JTAG_MAX_PAD_SIZE / 32];
+};
+
+/*
+ * Multi generation support is enabled by fops and low level assped function
+ * mapping using asped_jtag_functions struct as config mechanism.
+ */
+
+struct jtag_low_level_functions {
+	void (*output_disable)(struct aspeed_jtag *aspeed_jtag);
+	void (*master_enable)(struct aspeed_jtag *aspeed_jtag);
+	int (*xfer_push_data)(struct aspeed_jtag *aspeed_jtag,
+			      enum jtag_xfer_type type, u32 bits_len);
+	int (*xfer_push_data_last)(struct aspeed_jtag *aspeed_jtag,
+				   enum jtag_xfer_type type, u32 bits_len);
+	void (*xfer_sw)(struct aspeed_jtag *aspeed_jtag, struct jtag_xfer *xfer,
+			u32 *data);
+	int (*xfer_hw)(struct aspeed_jtag *aspeed_jtag, struct jtag_xfer *xfer,
+		       u32 *data);
+	void (*xfer_hw_fifo_delay)(void);
+	void (*xfer_sw_delay)(struct aspeed_jtag *aspeed_jtag);
+	irqreturn_t (*jtag_interrupt)(s32 this_irq, void *dev_id);
+};
+
+struct aspeed_jtag_functions {
+	const struct jtag_ops *aspeed_jtag_ops;
+	const struct jtag_low_level_functions *aspeed_jtag_llops;
+};
+
+#ifdef DEBUG_JTAG
+static char *end_status_str[] = { "tlr",   "idle",  "selDR", "capDR",
+				  "sDR",   "ex1DR", "pDR",   "ex2DR",
+				  "updDR", "selIR", "capIR", "sIR",
+				  "ex1IR", "pIR",   "ex2IR", "updIR" };
+#endif
+
+static u32 aspeed_jtag_read(struct aspeed_jtag *aspeed_jtag, u32 reg)
+{
+	u32 val = readl(aspeed_jtag->reg_base + reg);
+
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev, "read:%s val = 0x%08x\n", regnames[reg], val);
+#endif
+	return val;
+}
+
+static void aspeed_jtag_write(struct aspeed_jtag *aspeed_jtag, u32 val, u32 reg)
+{
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev, "write:%s val = 0x%08x\n", regnames[reg],
+		val);
+#endif
+	writel(val, aspeed_jtag->reg_base + reg);
+}
+
+static int aspeed_jtag_freq_set(struct jtag *jtag, u32 freq)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+	unsigned long apb_frq;
+	u32 tck_val;
+	u16 div;
+
+	if (!freq)
+		return -EINVAL;
+
+	apb_frq = clk_get_rate(aspeed_jtag->pclk);
+	if (!apb_frq)
+		return -EOPNOTSUPP;
+
+	div = (apb_frq - 1) / freq;
+	tck_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK);
+	aspeed_jtag_write(aspeed_jtag,
+			  (tck_val & ~ASPEED_JTAG_TCK_DIVISOR_MASK) | div,
+			  ASPEED_JTAG_TCK);
+	return 0;
+}
+
+static int aspeed_jtag_freq_set_26xx(struct jtag *jtag, u32 freq)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+	unsigned long apb_frq;
+	u32 tck_val;
+	u16 div;
+
+	if (!freq)
+		return -EINVAL;
+
+	apb_frq = clk_get_rate(aspeed_jtag->pclk);
+	if (!apb_frq)
+		return -EOPNOTSUPP;
+
+	div = (apb_frq - 1) / freq;
+	tck_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
+	aspeed_jtag_write(aspeed_jtag,
+			  (tck_val & ~ASPEED_JTAG_CLK_DIVISOR_MASK) | div,
+			  ASPEED_JTAG_GBLCTRL);
+	return 0;
+}
+
+static int aspeed_jtag_freq_get(struct jtag *jtag, u32 *frq)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+	u32 pclk;
+	u32 tck;
+
+	pclk = clk_get_rate(aspeed_jtag->pclk);
+	tck = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK);
+	*frq = pclk / (ASPEED_JTAG_TCK_GET_DIV(tck) + 1);
+
+	return 0;
+}
+
+static int aspeed_jtag_freq_get_26xx(struct jtag *jtag, u32 *frq)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+	u32 pclk;
+	u32 tck;
+
+	pclk = clk_get_rate(aspeed_jtag->pclk);
+	tck = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
+	*frq = pclk / (ASPEED_JTAG_CLK_GET_DIV(tck) + 1);
+
+	return 0;
+}
+
+static inline void aspeed_jtag_output_disable(struct aspeed_jtag *aspeed_jtag)
+{
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_CTRL);
+}
+
+static inline void
+aspeed_jtag_output_disable_26xx(struct aspeed_jtag *aspeed_jtag)
+{
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_CTRL);
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_GBLCTRL);
+}
+
+static inline void aspeed_jtag_master(struct aspeed_jtag *aspeed_jtag)
+{
+	aspeed_jtag_write(aspeed_jtag,
+			  (ASPEED_JTAG_CTL_ENG_EN | ASPEED_JTAG_CTL_ENG_OUT_EN),
+			  ASPEED_JTAG_CTRL);
+
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_SW_MODE_EN | ASPEED_JTAG_SW_MODE_TDIO,
+			  ASPEED_JTAG_SW);
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_ISR_INST_PAUSE |
+				  ASPEED_JTAG_ISR_INST_COMPLETE |
+				  ASPEED_JTAG_ISR_DATA_PAUSE |
+				  ASPEED_JTAG_ISR_DATA_COMPLETE |
+				  ASPEED_JTAG_ISR_INST_PAUSE_EN |
+				  ASPEED_JTAG_ISR_INST_COMPLETE_EN |
+				  ASPEED_JTAG_ISR_DATA_PAUSE_EN |
+				  ASPEED_JTAG_ISR_DATA_COMPLETE_EN,
+			  ASPEED_JTAG_ISR); /* Enable Interrupt */
+}
+
+static inline void aspeed_jtag_master_26xx(struct aspeed_jtag *aspeed_jtag)
+{
+	if (aspeed_jtag->mode & JTAG_XFER_HW_MODE) {
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_GBLCTRL_ENG_MODE_EN |
+					  ASPEED_JTAG_GBLCTRL_ENG_OUT_EN,
+				  ASPEED_JTAG_GBLCTRL);
+	} else {
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_GBLCTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_CTL_ENG_EN |
+					  ASPEED_JTAG_CTL_ENG_OUT_EN,
+				  ASPEED_JTAG_CTRL);
+
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_SW_MODE_EN |
+					  ASPEED_JTAG_SW_MODE_TDIO,
+				  ASPEED_JTAG_SW);
+	}
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_EN |
+				  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT,
+			  ASPEED_JTAG_INTCTRL); /* Enable HW2 IRQ */
+
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_ISR_INST_PAUSE |
+				  ASPEED_JTAG_ISR_INST_COMPLETE |
+				  ASPEED_JTAG_ISR_DATA_PAUSE |
+				  ASPEED_JTAG_ISR_DATA_COMPLETE |
+				  ASPEED_JTAG_ISR_INST_PAUSE_EN |
+				  ASPEED_JTAG_ISR_INST_COMPLETE_EN |
+				  ASPEED_JTAG_ISR_DATA_PAUSE_EN |
+				  ASPEED_JTAG_ISR_DATA_COMPLETE_EN,
+			  ASPEED_JTAG_ISR); /* Enable HW1 Interrupts */
+}
+
+static int aspeed_jtag_mode_set(struct jtag *jtag, struct jtag_mode *jtag_mode)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+	switch (jtag_mode->feature) {
+	case JTAG_XFER_MODE:
+		aspeed_jtag->mode = jtag_mode->mode;
+		aspeed_jtag->llops->master_enable(aspeed_jtag);
+		break;
+	case JTAG_CONTROL_MODE:
+		if (jtag_mode->mode == JTAG_MASTER_OUTPUT_DISABLE)
+			aspeed_jtag->llops->output_disable(aspeed_jtag);
+		else if (jtag_mode->mode == JTAG_MASTER_MODE)
+			aspeed_jtag->llops->master_enable(aspeed_jtag);
+		break;
+	default:
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/*
+ * We read and write from an unused JTAG Master controller register in SW
+ * mode to create a delay in xfers.
+ * We found this mechanism better than any udelay or usleep option.
+ */
+static inline void aspeed_jtag_sw_delay_26xx(struct aspeed_jtag *aspeed_jtag)
+{
+	u32 read_reg = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_PADCTRL1);
+
+	aspeed_jtag_write(aspeed_jtag, read_reg, ASPEED_JTAG_PADCTRL1);
+}
+
+static char aspeed_jtag_tck_cycle(struct aspeed_jtag *aspeed_jtag, u8 tms,
+				  u8 tdi)
+{
+	char tdo = 0;
+
+	/* TCK = 0 */
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_SW_MODE_EN |
+				  (tms * ASPEED_JTAG_SW_MODE_TMS) |
+				  (tdi * ASPEED_JTAG_SW_MODE_TDIO),
+			  ASPEED_JTAG_SW);
+
+	/* Wait until JTAG Master controller finishes the operation */
+	if (aspeed_jtag->llops->xfer_sw_delay)
+		aspeed_jtag->llops->xfer_sw_delay(aspeed_jtag);
+	else
+		aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW);
+
+	/* TCK = 1 */
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_SW_MODE_EN | ASPEED_JTAG_SW_MODE_TCK |
+				  (tms * ASPEED_JTAG_SW_MODE_TMS) |
+				  (tdi * ASPEED_JTAG_SW_MODE_TDIO),
+			  ASPEED_JTAG_SW);
+
+	/* Wait until JTAG Master controller finishes the operation */
+	if (aspeed_jtag->llops->xfer_sw_delay)
+		aspeed_jtag->llops->xfer_sw_delay(aspeed_jtag);
+
+	if (aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) &
+	    ASPEED_JTAG_SW_MODE_TDIO)
+		tdo = 1;
+
+	return tdo;
+}
+
+static int aspeed_jtag_bitbang(struct jtag *jtag,
+			       struct bitbang_packet *bitbang,
+			       struct tck_bitbang *bitbang_data)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+	int i = 0;
+
+	for (i = 0; i < bitbang->length; i++) {
+		bitbang_data[i].tdo =
+			aspeed_jtag_tck_cycle(aspeed_jtag, bitbang_data[i].tms,
+					      bitbang_data[i].tdi);
+	}
+	return 0;
+}
+
+static inline void aspeed_jtag_xfer_hw_fifo_delay_26xx(void)
+{
+	udelay(AST26XX_FIFO_UDELAY);
+}
+
+static int aspeed_jtag_isr_wait(struct aspeed_jtag *aspeed_jtag, u32 bit)
+{
+	int res = 0;
+#ifdef USE_INTERRUPTS
+	res = wait_event_interruptible(aspeed_jtag->jtag_wq,
+				       aspeed_jtag->flag & bit);
+	aspeed_jtag->flag &= ~bit;
+#else
+	u32 status = 0;
+	u32 iterations = 0;
+
+	while ((status & bit) == 0) {
+		status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR);
+#ifdef DEBUG_JTAG
+		dev_dbg(aspeed_jtag->dev, "%s  = 0x%08x\n", __func__, status);
+#endif
+		iterations++;
+		if (iterations > WAIT_ITERATIONS) {
+			dev_err(aspeed_jtag->dev, "%s %d in ASPEED_JTAG_ISR\n",
+				"aspeed_jtag driver timed out waiting for bit",
+				bit);
+			res = -EFAULT;
+			break;
+		}
+		if ((status & ASPEED_JTAG_ISR_DATA_COMPLETE) == 0) {
+			if (iterations % 25 == 0)
+				usleep_range(1, 5);
+			else
+				udelay(1);
+		}
+	}
+	aspeed_jtag_write(aspeed_jtag, bit | (status & 0xf), ASPEED_JTAG_ISR);
+#endif
+	return res;
+}
+
+static int aspeed_jtag_wait_shift_complete(struct aspeed_jtag *aspeed_jtag)
+{
+	int res = 0;
+#ifdef USE_INTERRUPTS
+	res = wait_event_interruptible(aspeed_jtag->jtag_wq,
+				       aspeed_jtag->flag &
+				       ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT);
+	aspeed_jtag->flag &= ~ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT;
+#else
+	u32 status = 0;
+	u32 iterations = 0;
+
+	while ((status & ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT) == 0) {
+		status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_INTCTRL);
+#ifdef DEBUG_JTAG
+		dev_dbg(aspeed_jtag->dev, "%s  = 0x%08x\n", __func__, status);
+#endif
+		iterations++;
+		if (iterations > WAIT_ITERATIONS) {
+			dev_err(aspeed_jtag->dev,
+				"aspeed_jtag driver timed out waiting for shift completed\n");
+			res = -EFAULT;
+			break;
+		}
+		if (iterations % 25 == 0)
+			usleep_range(1, 5);
+		else
+			udelay(1);
+	}
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT |
+				  ASPEED_JTAG_INTCTRL_SHCPL_IRQ_EN,
+			  ASPEED_JTAG_INTCTRL);
+#endif
+	return res;
+}
+
+static void aspeed_jtag_set_tap_state(struct aspeed_jtag *aspeed_jtag,
+				      enum jtag_tapstate from_state,
+				      enum jtag_tapstate end_state)
+{
+	int i = 0;
+	enum jtag_tapstate from, to;
+
+	from = from_state;
+	to = end_state;
+
+	if (from == JTAG_STATE_CURRENT)
+		from = aspeed_jtag->status;
+
+	for (i = 0; i < _tms_cycle_lookup[from][to].count; i++)
+		aspeed_jtag_tck_cycle(aspeed_jtag,
+				      ((_tms_cycle_lookup[from][to].tmsbits
+				      >> i) & 0x1), 0);
+	aspeed_jtag->current_state = end_state;
+}
+
+static void aspeed_jtag_set_tap_state_sw(struct aspeed_jtag *aspeed_jtag,
+					 struct jtag_tap_state *tapstate)
+{
+	/* SW mode from curent tap state -> to end_state */
+	if (tapstate->reset) {
+		int i = 0;
+
+		for (i = 0; i < ASPEED_JTAG_RESET_CNTR; i++)
+			aspeed_jtag_tck_cycle(aspeed_jtag, 1, 0);
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
+	}
+
+	aspeed_jtag_set_tap_state(aspeed_jtag, tapstate->from,
+				  tapstate->endstate);
+}
+
+static void aspeed_jtag_set_tap_state_sw_26xx(struct aspeed_jtag *aspeed_jtag,
+					      struct jtag_tap_state *tapstate)
+{
+	u32 gblctrl;
+	u32 jtagctrl;
+	u32 enginectrl;
+	int i;
+	/* SW mode from current tap state -> to end_state */
+	if (tapstate->reset) {
+		/* Hardware starts in TLRRESET state - TRST external pin low*/
+		gblctrl = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
+		enginectrl = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_EC);
+		jtagctrl = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_CTRL);
+		for (i = 0; i < ASPEED_JTAG_RESET_CNTR; i++)
+			aspeed_jtag_tck_cycle(aspeed_jtag, 1, 0);
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
+		/* Transition TRST External Pin from low to high*/
+		aspeed_jtag_write(aspeed_jtag,
+				  jtagctrl | ASPEED_JTAG_CTL_ENG_OUT_EN,
+				  ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  enginectrl | ASPEED_JTAG_EC_TRST,
+				  ASPEED_JTAG_EC);
+		aspeed_jtag_write(aspeed_jtag, gblctrl |
+				  ASPEED_JTAG_GBLCTRL_ENG_OUT_EN |
+				  ASPEED_JTAG_GBLCTRL_TRST,
+				  ASPEED_JTAG_GBLCTRL);
+		aspeed_jtag_set_tap_state(aspeed_jtag, aspeed_jtag->current_state,
+					  JTAG_STATE_IDLE);
+	}
+
+	aspeed_jtag_set_tap_state(aspeed_jtag, tapstate->from, tapstate->endstate);
+}
+
+static int aspeed_jtag_status_set(struct jtag *jtag,
+				  struct jtag_tap_state *tapstate)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev, "Set TAP state: %s\n",
+		end_status_str[tapstate->endstate]);
+#endif
+
+	if (!(aspeed_jtag->mode & JTAG_XFER_HW_MODE)) {
+		aspeed_jtag_set_tap_state_sw(aspeed_jtag, tapstate);
+		return 0;
+	}
+
+	/* x TMS high + 1 TMS low */
+	if (tapstate->reset) {
+		/* Disable sw mode */
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+		mdelay(1);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_CTL_ENG_EN |
+					  ASPEED_JTAG_CTL_ENG_OUT_EN |
+					  ASPEED_JTAG_CTL_FORCE_TMS,
+				  ASPEED_JTAG_CTRL);
+		mdelay(1);
+		aspeed_jtag_write(aspeed_jtag, ASPEED_JTAG_SW_TDIO,
+				  ASPEED_JTAG_SW);
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
+	}
+
+	return 0;
+}
+
+static void aspeed_jtag_shctrl_tms_mask(enum jtag_tapstate from,
+					enum jtag_tapstate to,
+					enum jtag_tapstate there,
+					enum jtag_tapstate endstate,
+					u32 start_shift, u32 end_shift,
+					u32 *tms_mask)
+{
+	u32 pre_tms = start_shift ? _tms_cycle_lookup[from][to].count : 0;
+	u32 post_tms = end_shift ? _tms_cycle_lookup[there][endstate].count : 0;
+	u32 tms_value = start_shift ? _tms_cycle_lookup[from][to].tmsbits : 0;
+
+	tms_value |= end_shift ? _tms_cycle_lookup[there][endstate].tmsbits
+					 << pre_tms :
+				 0;
+	*tms_mask = start_shift | ASPEED_JTAG_SHCTRL_PRE_TMS(pre_tms) |
+		    end_shift | ASPEED_JTAG_SHCTRL_POST_TMS(post_tms) |
+		    ASPEED_JTAG_SHCTRL_TMS(tms_value);
+}
+
+static void aspeed_jtag_set_tap_state_hw2(struct aspeed_jtag *aspeed_jtag,
+					  struct jtag_tap_state *tapstate)
+{
+	u32 gblctrl;
+	u32 jtagctrl;
+	u32 enginectrl;
+	/* x TMS high + 1 TMS low */
+	if (tapstate->reset) {
+		/* Disable sw mode */
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+		udelay(AST26XX_JTAG_CTRL_UDELAY);
+		gblctrl = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
+		enginectrl = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_EC);
+		jtagctrl = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  gblctrl |
+				  ASPEED_JTAG_GBLCTRL_ENG_MODE_EN |
+				  ASPEED_JTAG_GBLCTRL_ENG_OUT_EN |
+				  ASPEED_JTAG_GBLCTRL_RESET_FIFO |
+				  ASPEED_JTAG_GBLCTRL_TRST |
+				  ASPEED_JTAG_GBLCTRL_FORCE_TMS,
+				  ASPEED_JTAG_GBLCTRL);
+		udelay(AST26XX_JTAG_CTRL_UDELAY);
+		aspeed_jtag_write(aspeed_jtag, jtagctrl |
+				  ASPEED_JTAG_CTL_ENG_OUT_EN,
+				  ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag, enginectrl |
+				  ASPEED_JTAG_EC_TRST,
+				  ASPEED_JTAG_EC);
+		udelay(AST26XX_JTAG_CTRL_UDELAY);
+		aspeed_jtag->current_state = JTAG_STATE_TLRESET;
+	} else if (tapstate->endstate == JTAG_STATE_IDLE &&
+		   aspeed_jtag->current_state != JTAG_STATE_IDLE) {
+		/* Always go to RTI, do not wait for shift operation */
+		aspeed_jtag_set_tap_state(aspeed_jtag,
+					  aspeed_jtag->current_state,
+					  JTAG_STATE_IDLE);
+		aspeed_jtag->current_state = JTAG_STATE_IDLE;
+	}
+}
+
+static int aspeed_jtag_status_set_26xx(struct jtag *jtag,
+				       struct jtag_tap_state *tapstate)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev, "Set TAP state: status %s from %s to %s\n",
+		end_status_str[aspeed_jtag->current_state],
+		end_status_str[tapstate->from],
+		end_status_str[tapstate->endstate]);
+#endif
+
+	if (!(aspeed_jtag->mode & JTAG_XFER_HW_MODE)) {
+		aspeed_jtag_set_tap_state_sw_26xx(aspeed_jtag, tapstate);
+		return 0;
+	}
+
+	aspeed_jtag_set_tap_state_hw2(aspeed_jtag, tapstate);
+	return 0;
+}
+
+static void aspeed_jtag_xfer_sw(struct aspeed_jtag *aspeed_jtag,
+				struct jtag_xfer *xfer, u32 *data)
+{
+	unsigned long remain_xfer = xfer->length;
+	unsigned long shift_bits = 0;
+	unsigned long index = 0;
+	unsigned long tdi;
+	char tdo;
+
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev, "SW JTAG SHIFT %s, length = %d\n",
+		(xfer->type == JTAG_SIR_XFER) ? "IR" : "DR", xfer->length);
+#endif
+
+	if (xfer->type == JTAG_SIR_XFER)
+		aspeed_jtag_set_tap_state(aspeed_jtag, xfer->from,
+					  JTAG_STATE_SHIFTIR);
+	else
+		aspeed_jtag_set_tap_state(aspeed_jtag, xfer->from,
+					  JTAG_STATE_SHIFTDR);
+
+	tdi = ASPEED_JTAG_GET_TDI(xfer->direction, data[index]);
+	data[index] = 0;
+	while (remain_xfer > 1) {
+		tdo = aspeed_jtag_tck_cycle(aspeed_jtag, 0,
+					    tdi & ASPEED_JTAG_DATA_MSB);
+		data[index] |= tdo
+			       << (shift_bits % ASPEED_JTAG_DATA_CHUNK_SIZE);
+		tdi >>= 1;
+		shift_bits++;
+		remain_xfer--;
+
+		if (shift_bits % ASPEED_JTAG_DATA_CHUNK_SIZE == 0) {
+			tdo = 0;
+			index++;
+			tdi = ASPEED_JTAG_GET_TDI(xfer->direction, data[index]);
+			data[index] = 0;
+		}
+	}
+
+	if ((xfer->endstate == (xfer->type == JTAG_SIR_XFER ?
+					JTAG_STATE_SHIFTIR :
+					JTAG_STATE_SHIFTDR))) {
+		/* Stay in Shift IR/DR*/
+		tdo = aspeed_jtag_tck_cycle(aspeed_jtag, 0,
+					    tdi & ASPEED_JTAG_DATA_MSB);
+		data[index] |= tdo
+			       << (shift_bits % ASPEED_JTAG_DATA_CHUNK_SIZE);
+	} else {
+		/* Goto end state */
+		tdo = aspeed_jtag_tck_cycle(aspeed_jtag, 1,
+					    tdi & ASPEED_JTAG_DATA_MSB);
+		data[index] |= tdo
+			       << (shift_bits % ASPEED_JTAG_DATA_CHUNK_SIZE);
+		aspeed_jtag->status = (xfer->type == JTAG_SIR_XFER) ?
+					      JTAG_STATE_EXIT1IR :
+					      JTAG_STATE_EXIT1DR;
+		aspeed_jtag_set_tap_state(aspeed_jtag, aspeed_jtag->status,
+					  xfer->endstate);
+	}
+}
+
+static int aspeed_jtag_xfer_push_data_26xx(struct aspeed_jtag *aspeed_jtag,
+					   enum jtag_xfer_type type,
+					   u32 bits_len)
+{
+	int res = 0;
+
+	aspeed_jtag_write(aspeed_jtag, ASPEED_JTAG_TRANS_LEN(bits_len),
+			  ASPEED_JTAG_CTRL);
+	if (type == JTAG_SIR_XFER) {
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_TRANS_LEN(bits_len) |
+					  ASPEED_JTAG_CTL_26XX_INST_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_INST_PAUSE);
+	} else {
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_TRANS_LEN(bits_len) |
+					  ASPEED_JTAG_CTL_DATA_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_DATA_PAUSE);
+	}
+	return res;
+}
+
+static int aspeed_jtag_xfer_push_data(struct aspeed_jtag *aspeed_jtag,
+				      enum jtag_xfer_type type, u32 bits_len)
+{
+	int res = 0;
+
+	if (type == JTAG_SIR_XFER) {
+		aspeed_jtag_write(aspeed_jtag, ASPEED_JTAG_IOUT_LEN(bits_len),
+				  ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_IOUT_LEN(bits_len) |
+					  ASPEED_JTAG_CTL_INST_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_INST_PAUSE);
+	} else {
+		aspeed_jtag_write(aspeed_jtag, ASPEED_JTAG_DOUT_LEN(bits_len),
+				  ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_DOUT_LEN(bits_len) |
+					  ASPEED_JTAG_CTL_DATA_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_DATA_PAUSE);
+	}
+	return res;
+}
+
+static int aspeed_jtag_xfer_push_data_last_26xx(struct aspeed_jtag *aspeed_jtag,
+						enum jtag_xfer_type type,
+						u32 shift_bits)
+{
+	int res = 0;
+
+	aspeed_jtag_write(aspeed_jtag,
+			  ASPEED_JTAG_TRANS_LEN(shift_bits) |
+				  ASPEED_JTAG_CTL_26XX_LASPEED_TRANS,
+			  ASPEED_JTAG_CTRL);
+	if (type == JTAG_SIR_XFER) {
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_TRANS_LEN(shift_bits) |
+					  ASPEED_JTAG_CTL_26XX_LASPEED_TRANS |
+					  ASPEED_JTAG_CTL_26XX_INST_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_INST_COMPLETE);
+	} else {
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_TRANS_LEN(shift_bits) |
+					  ASPEED_JTAG_CTL_26XX_LASPEED_TRANS |
+					  ASPEED_JTAG_CTL_DATA_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_DATA_COMPLETE);
+	}
+	return res;
+}
+
+static int aspeed_jtag_xfer_push_data_last(struct aspeed_jtag *aspeed_jtag,
+					   enum jtag_xfer_type type,
+					   u32 shift_bits)
+{
+	int res = 0;
+
+	if (type == JTAG_SIR_XFER) {
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_IOUT_LEN(shift_bits) |
+					  ASPEED_JTAG_CTL_LASPEED_INST,
+				  ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_IOUT_LEN(shift_bits) |
+					  ASPEED_JTAG_CTL_LASPEED_INST |
+					  ASPEED_JTAG_CTL_INST_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_INST_COMPLETE);
+	} else {
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_DOUT_LEN(shift_bits) |
+					  ASPEED_JTAG_CTL_LASPEED_DATA,
+				  ASPEED_JTAG_CTRL);
+		aspeed_jtag_write(aspeed_jtag,
+				  ASPEED_JTAG_DOUT_LEN(shift_bits) |
+					  ASPEED_JTAG_CTL_LASPEED_DATA |
+					  ASPEED_JTAG_CTL_DATA_EN,
+				  ASPEED_JTAG_CTRL);
+		res = aspeed_jtag_isr_wait(aspeed_jtag,
+					   ASPEED_JTAG_ISR_DATA_COMPLETE);
+	}
+	return res;
+}
+
+static int aspeed_jtag_xfer_hw(struct aspeed_jtag *aspeed_jtag,
+			       struct jtag_xfer *xfer, u32 *data)
+{
+	unsigned long remain_xfer = xfer->length;
+	unsigned long index = 0;
+	char shift_bits;
+	u32 data_reg;
+	u32 scan_end;
+	union pad_config padding;
+	int retval = 0;
+
+	padding.int_value = xfer->padding;
+
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev, "HW JTAG SHIFT %s, length = %d pad = 0x%x\n",
+		(xfer->type == JTAG_SIR_XFER) ? "IR" : "DR", xfer->length,
+		xfer->padding);
+#endif
+	data_reg = xfer->type == JTAG_SIR_XFER ? ASPEED_JTAG_INST :
+						 ASPEED_JTAG_DATA;
+	if (xfer->endstate == JTAG_STATE_SHIFTIR ||
+	    xfer->endstate == JTAG_STATE_SHIFTDR ||
+	    xfer->endstate == JTAG_STATE_PAUSEIR ||
+	    xfer->endstate == JTAG_STATE_PAUSEDR) {
+		scan_end = 0;
+	} else {
+		if (padding.post_pad_number)
+			scan_end = 0;
+		else
+			scan_end = 1;
+	}
+
+	/* Perform pre padding */
+	if (padding.pre_pad_number) {
+		struct jtag_xfer pre_xfer = {
+			.type = xfer->type,
+			.direction = JTAG_WRITE_XFER,
+			.from = xfer->from,
+			.endstate = xfer->type == JTAG_SIR_XFER ?
+				    JTAG_STATE_SHIFTIR : JTAG_STATE_SHIFTDR,
+			.padding = 0,
+			.length = padding.pre_pad_number,
+		};
+		if (padding.pre_pad_number > ASPEED_JTAG_MAX_PAD_SIZE)
+			return -EINVAL;
+		retval = aspeed_jtag_xfer_hw(aspeed_jtag, &pre_xfer,
+					     padding.pad_data ?
+					     aspeed_jtag->pad_data_one :
+					     aspeed_jtag->pad_data_zero);
+		if (retval)
+			return retval;
+	}
+
+	while (remain_xfer) {
+		if (xfer->direction & JTAG_WRITE_XFER)
+			aspeed_jtag_write(aspeed_jtag, data[index], data_reg);
+		else
+			aspeed_jtag_write(aspeed_jtag, 0, data_reg);
+		if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+			aspeed_jtag->llops->xfer_hw_fifo_delay();
+
+		if (remain_xfer > ASPEED_JTAG_DATA_CHUNK_SIZE) {
+#ifdef DEBUG_JTAG
+			dev_dbg(aspeed_jtag->dev,
+				"Chunk len=%d chunk_size=%d remain_xfer=%lu\n",
+				xfer->length, ASPEED_JTAG_DATA_CHUNK_SIZE,
+				remain_xfer);
+#endif
+			shift_bits = ASPEED_JTAG_DATA_CHUNK_SIZE;
+
+			/*
+			 * Transmit bytes that were not equals to column length
+			 * and after the transfer go to Pause IR/DR.
+			 */
+			if (aspeed_jtag->llops->xfer_push_data(aspeed_jtag,
+							       xfer->type,
+							       shift_bits)
+							       != 0) {
+				return -EFAULT;
+			}
+		} else {
+			/*
+			 * Read bytes equals to column length
+			 */
+			shift_bits = remain_xfer;
+			if (scan_end) {
+				/*
+				 * If this data is the end of the transmission
+				 * send remaining bits and go to endstate
+				 */
+#ifdef DEBUG_JTAG
+				dev_dbg(aspeed_jtag->dev,
+					"Last len=%d chunk_size=%d remain_xfer=%lu\n",
+					xfer->length,
+					ASPEED_JTAG_DATA_CHUNK_SIZE,
+					remain_xfer);
+#endif
+				if (aspeed_jtag->llops->xfer_push_data_last(
+					    aspeed_jtag, xfer->type,
+					    shift_bits) != 0) {
+					return -EFAULT;
+				}
+			} else {
+				/*
+				 * If transmission is waiting for additional
+				 * data send remaining bits and then go to
+				 * Pause IR/DR.
+				 */
+#ifdef DEBUG_JTAG
+				dev_dbg(aspeed_jtag->dev,
+					"Tail len=%d chunk_size=%d remain_xfer=%lu\n",
+					xfer->length,
+					ASPEED_JTAG_DATA_CHUNK_SIZE,
+					remain_xfer);
+#endif
+				if (aspeed_jtag->llops->xfer_push_data(
+					    aspeed_jtag, xfer->type,
+					    shift_bits) != 0) {
+					return -EFAULT;
+				}
+			}
+		}
+
+		if (xfer->direction & JTAG_READ_XFER) {
+			if (shift_bits < ASPEED_JTAG_DATA_CHUNK_SIZE) {
+				data[index] =
+					aspeed_jtag_read(aspeed_jtag, data_reg);
+
+				data[index] >>= ASPEED_JTAG_DATA_CHUNK_SIZE -
+						shift_bits;
+			} else {
+				data[index] =
+					aspeed_jtag_read(aspeed_jtag, data_reg);
+			}
+			if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+				aspeed_jtag->llops->xfer_hw_fifo_delay();
+		}
+
+		remain_xfer = remain_xfer - shift_bits;
+		index++;
+	}
+
+	/* Perform post padding */
+	if (padding.post_pad_number) {
+		struct jtag_xfer post_xfer = {
+			.type = xfer->type,
+			.direction = JTAG_WRITE_XFER,
+			.from = xfer->from,
+			.endstate = xfer->endstate,
+			.padding = 0,
+			.length = padding.post_pad_number,
+		};
+		if (padding.post_pad_number > ASPEED_JTAG_MAX_PAD_SIZE)
+			return -EINVAL;
+		retval = aspeed_jtag_xfer_hw(aspeed_jtag, &post_xfer,
+					     padding.pad_data ?
+					     aspeed_jtag->pad_data_one :
+					     aspeed_jtag->pad_data_zero);
+		if (retval)
+			return retval;
+	}
+	return 0;
+}
+
+static int aspeed_jtag_xfer(struct jtag *jtag, struct jtag_xfer *xfer,
+			    u8 *xfer_data)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+	if (!(aspeed_jtag->mode & JTAG_XFER_HW_MODE)) {
+		/* SW mode */
+		aspeed_jtag_write(aspeed_jtag, ASPEED_JTAG_SW_TDIO,
+				  ASPEED_JTAG_SW);
+
+		aspeed_jtag->llops->xfer_sw(aspeed_jtag, xfer,
+					    (u32 *)xfer_data);
+	} else {
+		/* HW mode */
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+		if (aspeed_jtag->llops->xfer_hw(aspeed_jtag, xfer,
+						(u32 *)xfer_data) != 0)
+			return -EFAULT;
+	}
+
+	aspeed_jtag->status = xfer->endstate;
+	return 0;
+}
+
+static int aspeed_jtag_xfer_hw2(struct aspeed_jtag *aspeed_jtag,
+				struct jtag_xfer *xfer, u32 *data)
+{
+	unsigned long remain_xfer = xfer->length;
+	unsigned long partial_xfer_size = 0;
+	unsigned long index = 0;
+	u32 shift_bits;
+	u32 data_reg;
+	u32 reg_val;
+	enum jtag_tapstate shift;
+	enum jtag_tapstate exit;
+	enum jtag_tapstate exitx;
+	enum jtag_tapstate pause;
+	enum jtag_tapstate endstate;
+	u32 start_shift;
+	u32 end_shift;
+	u32 tms_mask;
+
+	if (xfer->type == JTAG_SIR_XFER) {
+		data_reg = ASPEED_JTAG_SHDATA;
+		shift = JTAG_STATE_SHIFTIR;
+		pause = JTAG_STATE_PAUSEIR;
+		exit = JTAG_STATE_EXIT1IR;
+		exitx = JTAG_STATE_EXIT1DR;
+	} else {
+		data_reg = ASPEED_JTAG_SHDATA;
+		shift = JTAG_STATE_SHIFTDR;
+		pause = JTAG_STATE_PAUSEDR;
+		exit = JTAG_STATE_EXIT1DR;
+		exitx = JTAG_STATE_EXIT1IR;
+	}
+#ifdef DEBUG_JTAG
+	dev_dbg(aspeed_jtag->dev,
+		"HW2 JTAG SHIFT %s, length %d status %s from %s to %s then %s pad 0x%x\n",
+		(xfer->type == JTAG_SIR_XFER) ? "IR" : "DR", xfer->length,
+		end_status_str[aspeed_jtag->current_state],
+		end_status_str[xfer->from],
+		end_status_str[shift],
+		end_status_str[xfer->endstate], xfer->padding);
+#endif
+
+	if (aspeed_jtag->current_state == shift) {
+		start_shift = 0;
+	} else if (aspeed_jtag->current_state == JTAG_STATE_IDLE ||
+		   aspeed_jtag->current_state == JTAG_STATE_TLRESET ||
+		   aspeed_jtag->current_state == pause ||
+		   aspeed_jtag->current_state == exit ||
+		   aspeed_jtag->current_state == exitx) {
+		start_shift = ASPEED_JTAG_SHCTRL_START_SHIFT;
+	} else {
+		return -EINVAL;
+	}
+
+	if (xfer->endstate == shift) {
+		/*
+		 * In the case of shifting 1 bit of data and attempting to stay
+		 * in the SHIFT state, the AST2600 JTAG Master Controller in
+		 * Hardware mode 2 has been observed to go to EXIT1 IR/DR
+		 * instead of staying in the SHIFT IR/DR state. The following
+		 * code special cases this one bit shift and directs the state
+		 * machine to go to the PAUSE IR/DR state instead.
+		 * Alternatively, the application making driver calls can avoid
+		 * this situation as follows:
+		 *   1.) Bundle all of the shift bits  together into one call
+		 *       AND/OR
+		 *   2.) Direct all partial shifts to move to the PAUSE-IR/DR
+		 *       state.
+		 */
+		if (xfer->length == 1) {
+#ifdef DEBUG_JTAG
+			dev_warn(aspeed_jtag->dev, "JTAG Silicon WA: going to pause instead of shift");
+#endif
+			end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+			endstate = pause;
+		} else {
+			end_shift = 0;
+			endstate = shift;
+		}
+	} else if (xfer->endstate == exit) {
+		endstate = exit;
+		end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+	} else if (xfer->endstate == JTAG_STATE_IDLE) {
+		endstate = JTAG_STATE_IDLE;
+		end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+	} else if (xfer->endstate == pause) {
+		endstate = pause;
+		end_shift = ASPEED_JTAG_SHCTRL_END_SHIFT;
+	} else {
+		return -EINVAL;
+	}
+
+	aspeed_jtag_write(aspeed_jtag, xfer->padding, ASPEED_JTAG_PADCTRL0);
+
+	while (remain_xfer) {
+		unsigned long partial_xfer;
+		unsigned long partial_index;
+
+		if (remain_xfer > ASPEED_JTAG_HW2_DATA_CHUNK_SIZE)
+			partial_xfer_size = ASPEED_JTAG_HW2_DATA_CHUNK_SIZE;
+		else
+			partial_xfer_size = remain_xfer;
+
+		partial_index = index;
+		partial_xfer = partial_xfer_size;
+
+		reg_val = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_GBLCTRL);
+		aspeed_jtag_write(aspeed_jtag, reg_val |
+				  ASPEED_JTAG_GBLCTRL_RESET_FIFO,
+				  ASPEED_JTAG_GBLCTRL);
+
+		/* Switch internal FIFO into CPU mode */
+		reg_val = reg_val & ~BIT(24);
+		aspeed_jtag_write(aspeed_jtag, reg_val,
+				  ASPEED_JTAG_GBLCTRL);
+
+		while (partial_xfer) {
+			if (partial_xfer > ASPEED_JTAG_DATA_CHUNK_SIZE)
+				shift_bits = ASPEED_JTAG_DATA_CHUNK_SIZE;
+			else
+				shift_bits = partial_xfer;
+
+			if (xfer->direction & JTAG_WRITE_XFER)
+				aspeed_jtag_write(aspeed_jtag,
+						  data[partial_index++],
+						  data_reg);
+			else
+				aspeed_jtag_write(aspeed_jtag, 0, data_reg);
+			if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+				aspeed_jtag->llops->xfer_hw_fifo_delay();
+			partial_xfer = partial_xfer - shift_bits;
+		}
+		if (remain_xfer > ASPEED_JTAG_HW2_DATA_CHUNK_SIZE) {
+			shift_bits = ASPEED_JTAG_HW2_DATA_CHUNK_SIZE;
+
+			/*
+			 * Transmit bytes that were not equals to column length
+			 * and after the transfer go to Pause IR/DR.
+			 */
+
+			aspeed_jtag_shctrl_tms_mask(aspeed_jtag->current_state,
+						    shift, exit, endstate,
+						    start_shift, 0, &tms_mask);
+
+			reg_val = aspeed_jtag_read(aspeed_jtag,
+						   ASPEED_JTAG_GBLCTRL);
+			reg_val = reg_val & ~(GENMASK(22, 20));
+			aspeed_jtag_write(aspeed_jtag, reg_val |
+					  ASPEED_JTAG_GBLCTRL_FIFO_CTRL_MODE |
+					  ASPEED_JTAG_GBLCTRL_UPDT_SHIFT(
+						shift_bits),
+					  ASPEED_JTAG_GBLCTRL);
+
+			aspeed_jtag_write(aspeed_jtag, tms_mask |
+				ASPEED_JTAG_SHCTRL_LWRDT_SHIFT(shift_bits),
+				ASPEED_JTAG_SHCTRL);
+			aspeed_jtag_wait_shift_complete(aspeed_jtag);
+		} else {
+			/*
+			 * Read bytes equals to column length
+			 */
+			shift_bits = remain_xfer;
+			aspeed_jtag_shctrl_tms_mask(aspeed_jtag->current_state,
+						    shift, exit, endstate,
+						    start_shift, end_shift,
+						    &tms_mask);
+
+			reg_val = aspeed_jtag_read(aspeed_jtag,
+						   ASPEED_JTAG_GBLCTRL);
+			reg_val = reg_val & ~(GENMASK(22, 20));
+			aspeed_jtag_write(aspeed_jtag, reg_val |
+					  ASPEED_JTAG_GBLCTRL_FIFO_CTRL_MODE |
+					  ASPEED_JTAG_GBLCTRL_UPDT_SHIFT(
+						shift_bits),
+					  ASPEED_JTAG_GBLCTRL);
+
+			aspeed_jtag_write(aspeed_jtag, tms_mask |
+					  ASPEED_JTAG_SHCTRL_LWRDT_SHIFT(
+						  shift_bits),
+					  ASPEED_JTAG_SHCTRL);
+
+			aspeed_jtag_wait_shift_complete(aspeed_jtag);
+		}
+
+		partial_index = index;
+		partial_xfer = partial_xfer_size;
+		while (partial_xfer) {
+			if (partial_xfer >
+			    ASPEED_JTAG_DATA_CHUNK_SIZE) {
+				shift_bits =
+					ASPEED_JTAG_DATA_CHUNK_SIZE;
+				data[partial_index++] =
+					aspeed_jtag_read(aspeed_jtag,
+							 data_reg);
+
+			} else {
+				shift_bits = partial_xfer;
+				data[partial_index++] =
+					aspeed_jtag_read(aspeed_jtag,
+							 data_reg);
+			}
+			if (aspeed_jtag->llops->xfer_hw_fifo_delay)
+				aspeed_jtag->llops->xfer_hw_fifo_delay();
+			partial_xfer = partial_xfer - shift_bits;
+		}
+
+		remain_xfer = remain_xfer - partial_xfer_size;
+		index = partial_index;
+		start_shift = 0;
+	}
+	aspeed_jtag->current_state = endstate;
+	return 0;
+}
+
+static int aspeed_jtag_status_get(struct jtag *jtag, u32 *status)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+	*status = aspeed_jtag->current_state;
+	return 0;
+}
+
+static irqreturn_t aspeed_jtag_interrupt(s32 this_irq, void *dev_id)
+{
+	struct aspeed_jtag *aspeed_jtag = dev_id;
+	irqreturn_t ret;
+	u32 status;
+
+	status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR);
+
+	if (status & ASPEED_JTAG_ISR_INT_MASK) {
+		aspeed_jtag_write(aspeed_jtag,
+				  (status & ASPEED_JTAG_ISR_INT_MASK) |
+					  (status &
+					   ASPEED_JTAG_ISR_INT_EN_MASK),
+				  ASPEED_JTAG_ISR);
+		aspeed_jtag->flag |= status & ASPEED_JTAG_ISR_INT_MASK;
+	}
+
+	if (aspeed_jtag->flag) {
+		wake_up_interruptible(&aspeed_jtag->jtag_wq);
+		ret = IRQ_HANDLED;
+	} else {
+		dev_err(aspeed_jtag->dev, "irq status:%x\n", status);
+		ret = IRQ_NONE;
+	}
+	return ret;
+}
+
+static irqreturn_t aspeed_jtag_interrupt_hw2(s32 this_irq, void *dev_id)
+{
+	struct aspeed_jtag *aspeed_jtag = dev_id;
+	irqreturn_t ret;
+	u32 status;
+
+	status = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_INTCTRL);
+
+	if (status & ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT) {
+		aspeed_jtag_write(aspeed_jtag,
+				  status | ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT,
+				  ASPEED_JTAG_INTCTRL);
+		aspeed_jtag->flag |= status & ASPEED_JTAG_INTCTRL_SHCPL_IRQ_STAT;
+	}
+
+	if (aspeed_jtag->flag) {
+		wake_up_interruptible(&aspeed_jtag->jtag_wq);
+		ret = IRQ_HANDLED;
+	} else {
+		dev_err(aspeed_jtag->dev, "irq status:%x\n", status);
+		ret = IRQ_NONE;
+	}
+	return ret;
+}
+
+static int aspeed_jtag_enable(struct jtag *jtag)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+	aspeed_jtag->llops->master_enable(aspeed_jtag);
+	return 0;
+}
+
+static int aspeed_jtag_disable(struct jtag *jtag)
+{
+	struct aspeed_jtag *aspeed_jtag = jtag_priv(jtag);
+
+	aspeed_jtag->llops->output_disable(aspeed_jtag);
+	return 0;
+}
+
+static int aspeed_jtag_init(struct platform_device *pdev,
+			    struct aspeed_jtag *aspeed_jtag)
+{
+	struct resource *res;
+#ifdef USE_INTERRUPTS
+	int err;
+#endif
+	memset(aspeed_jtag->pad_data_one, ~0,
+	       sizeof(aspeed_jtag->pad_data_one));
+	memset(aspeed_jtag->pad_data_zero, 0,
+	       sizeof(aspeed_jtag->pad_data_zero));
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	aspeed_jtag->reg_base = devm_ioremap_resource(aspeed_jtag->dev, res);
+	if (IS_ERR(aspeed_jtag->reg_base))
+		return -ENOMEM;
+
+	aspeed_jtag->pclk = devm_clk_get(aspeed_jtag->dev, NULL);
+	if (IS_ERR(aspeed_jtag->pclk)) {
+		dev_err(aspeed_jtag->dev, "devm_clk_get failed\n");
+		return PTR_ERR(aspeed_jtag->pclk);
+	}
+
+#ifdef USE_INTERRUPTS
+	aspeed_jtag->irq = platform_get_irq(pdev, 0);
+	if (aspeed_jtag->irq < 0) {
+		dev_err(aspeed_jtag->dev, "no irq specified\n");
+		return -ENOENT;
+	}
+#endif
+
+	if (clk_prepare_enable(aspeed_jtag->pclk)) {
+		dev_err(aspeed_jtag->dev, "no irq specified\n");
+		return -ENOENT;
+	}
+
+	aspeed_jtag->rst = devm_reset_control_get_shared(&pdev->dev, NULL);
+	if (IS_ERR(aspeed_jtag->rst)) {
+		dev_err(aspeed_jtag->dev,
+			"missing or invalid reset controller device tree entry");
+		return PTR_ERR(aspeed_jtag->rst);
+	}
+	reset_control_deassert(aspeed_jtag->rst);
+
+#ifdef USE_INTERRUPTS
+	err = devm_request_irq(aspeed_jtag->dev, aspeed_jtag->irq,
+			       aspeed_jtag->llops->jtag_interrupt, 0,
+			       "aspeed-jtag", aspeed_jtag);
+	if (err) {
+		dev_err(aspeed_jtag->dev, "unable to get IRQ");
+		clk_disable_unprepare(aspeed_jtag->pclk);
+		return err;
+	}
+#endif
+
+	aspeed_jtag->llops->output_disable(aspeed_jtag);
+
+	aspeed_jtag->flag = 0;
+	aspeed_jtag->mode = 0;
+	init_waitqueue_head(&aspeed_jtag->jtag_wq);
+	return 0;
+}
+
+static int aspeed_jtag_deinit(struct platform_device *pdev,
+			      struct aspeed_jtag *aspeed_jtag)
+{
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_ISR);
+	/* Disable clock */
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_CTRL);
+	reset_control_assert(aspeed_jtag->rst);
+	clk_disable_unprepare(aspeed_jtag->pclk);
+	return 0;
+}
+
+static const struct jtag_ops aspeed_jtag_ops = {
+	.freq_get = aspeed_jtag_freq_get,
+	.freq_set = aspeed_jtag_freq_set,
+	.status_get = aspeed_jtag_status_get,
+	.status_set = aspeed_jtag_status_set,
+	.xfer = aspeed_jtag_xfer,
+	.mode_set = aspeed_jtag_mode_set,
+	.bitbang = aspeed_jtag_bitbang,
+	.enable = aspeed_jtag_enable,
+	.disable = aspeed_jtag_disable
+};
+
+static const struct jtag_ops aspeed_jtag_ops_26xx = {
+#ifdef ASPEED_JTAG_HW_MODE_2_ENABLE
+	.freq_get = aspeed_jtag_freq_get_26xx,
+	.freq_set = aspeed_jtag_freq_set_26xx,
+	.status_get = aspeed_jtag_status_get,
+	.status_set = aspeed_jtag_status_set_26xx,
+#else
+	.freq_get = aspeed_jtag_freq_get,
+	.freq_set = aspeed_jtag_freq_set,
+	.status_get = aspeed_jtag_status_get,
+	.status_set = aspeed_jtag_status_set,
+#endif
+	.xfer = aspeed_jtag_xfer,
+	.mode_set = aspeed_jtag_mode_set,
+	.bitbang = aspeed_jtag_bitbang,
+	.enable = aspeed_jtag_enable,
+	.disable = aspeed_jtag_disable
+};
+
+static const struct jtag_low_level_functions ast25xx_llops = {
+	.master_enable = aspeed_jtag_master,
+	.output_disable = aspeed_jtag_output_disable,
+	.xfer_push_data = aspeed_jtag_xfer_push_data,
+	.xfer_push_data_last = aspeed_jtag_xfer_push_data_last,
+	.xfer_sw = aspeed_jtag_xfer_sw,
+	.xfer_hw = aspeed_jtag_xfer_hw,
+	.xfer_hw_fifo_delay = NULL,
+	.xfer_sw_delay = NULL,
+	.jtag_interrupt = aspeed_jtag_interrupt
+};
+
+static const struct aspeed_jtag_functions ast25xx_functions = {
+	.aspeed_jtag_ops = &aspeed_jtag_ops,
+	.aspeed_jtag_llops = &ast25xx_llops
+};
+
+static const struct jtag_low_level_functions ast26xx_llops = {
+#ifdef ASPEED_JTAG_HW_MODE_2_ENABLE
+	.master_enable = aspeed_jtag_master_26xx,
+	.output_disable = aspeed_jtag_output_disable_26xx,
+	.xfer_push_data = aspeed_jtag_xfer_push_data_26xx,
+	.xfer_push_data_last = aspeed_jtag_xfer_push_data_last_26xx,
+	.xfer_sw = aspeed_jtag_xfer_sw,
+	.xfer_hw = aspeed_jtag_xfer_hw2,
+	.xfer_hw_fifo_delay = aspeed_jtag_xfer_hw_fifo_delay_26xx,
+	.xfer_sw_delay = aspeed_jtag_sw_delay_26xx,
+	.jtag_interrupt = aspeed_jtag_interrupt_hw2
+#else
+	.master_enable = aspeed_jtag_master,
+	.output_disable = aspeed_jtag_output_disable,
+	.xfer_push_data = aspeed_jtag_xfer_push_data_26xx,
+	.xfer_push_data_last = aspeed_jtag_xfer_push_data_last_26xx,
+	.xfer_sw = aspeed_jtag_xfer_sw,
+	.xfer_hw = aspeed_jtag_xfer_hw,
+	.xfer_hw_fifo_delay = aspeed_jtag_xfer_hw_fifo_delay_26xx,
+	.xfer_sw_delay = aspeed_jtag_sw_delay_26xx,
+	.jtag_interrupt = aspeed_jtag_interrupt
+#endif
+};
+
+static const struct aspeed_jtag_functions ast26xx_functions = {
+	.aspeed_jtag_ops = &aspeed_jtag_ops_26xx,
+	.aspeed_jtag_llops = &ast26xx_llops
+};
+
+static const struct of_device_id aspeed_jtag_of_match[] = {
+	{ .compatible = "aspeed,ast2400-jtag", .data = &ast25xx_functions },
+	{ .compatible = "aspeed,ast2500-jtag", .data = &ast25xx_functions },
+	{ .compatible = "aspeed,ast2600-jtag", .data = &ast26xx_functions },
+	{}
+};
+
+static int aspeed_jtag_probe(struct platform_device *pdev)
+{
+	struct aspeed_jtag *aspeed_jtag;
+	struct jtag *jtag;
+	const struct of_device_id *match;
+	const struct aspeed_jtag_functions *jtag_functions;
+	int err;
+
+	match = of_match_node(aspeed_jtag_of_match, pdev->dev.of_node);
+	if (!match)
+		return -ENODEV;
+	jtag_functions = match->data;
+
+	jtag = jtag_alloc(&pdev->dev, sizeof(*aspeed_jtag),
+			  jtag_functions->aspeed_jtag_ops);
+	if (!jtag)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, jtag);
+	aspeed_jtag = jtag_priv(jtag);
+	aspeed_jtag->dev = &pdev->dev;
+
+	aspeed_jtag->llops = jtag_functions->aspeed_jtag_llops;
+
+	/* Initialize device*/
+	err = aspeed_jtag_init(pdev, aspeed_jtag);
+	if (err)
+		goto err_jtag_init;
+
+	/* Initialize JTAG core structure*/
+	err = devm_jtag_register(aspeed_jtag->dev, jtag);
+	if (err)
+		goto err_jtag_register;
+
+	return 0;
+
+err_jtag_register:
+	aspeed_jtag_deinit(pdev, aspeed_jtag);
+err_jtag_init:
+	jtag_free(jtag);
+	return err;
+}
+
+static int aspeed_jtag_remove(struct platform_device *pdev)
+{
+	struct jtag *jtag = platform_get_drvdata(pdev);
+
+	aspeed_jtag_deinit(pdev, jtag_priv(jtag));
+	return 0;
+}
+
+static struct platform_driver aspeed_jtag_driver = {
+	.probe = aspeed_jtag_probe,
+	.remove = aspeed_jtag_remove,
+	.driver = {
+		.name = ASPEED_JTAG_NAME,
+		.of_match_table = aspeed_jtag_of_match,
+	},
+};
+module_platform_driver(aspeed_jtag_driver);
+
+MODULE_AUTHOR("Oleksandr Shamray <oleksandrs@mellanox.com>");
+MODULE_DESCRIPTION("ASPEED JTAG driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/jtag/jtag.c b/drivers/jtag/jtag.c
index 1fb8715a2380..d4f0250d56be 100644
--- a/drivers/jtag/jtag.c
+++ b/drivers/jtag/jtag.c
@@ -18,7 +18,7 @@ struct jtag {
 	struct miscdevice miscdev;
 	const struct jtag_ops *ops;
 	int id;
-	unsigned long *priv;
+	unsigned long priv[0];
 };
 
 static DEFINE_IDA(jtag_ida);
@@ -40,7 +40,6 @@ static long jtag_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 	u8 *xfer_data;
 	u32 data_size;
 	u32 value;
-	u32 active;
 	int err;
 
 	if (!arg)
@@ -189,15 +188,6 @@ static long jtag_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 
 		err = jtag->ops->mode_set(jtag, &mode);
 		break;
-	case JTAG_SIOCTRST:
-		if (!jtag->ops->trst_set)
-			return -EOPNOTSUPP;
-
-		if (get_user(active, (__u32 __user *)arg))
-			return -EFAULT;
-
-		err = jtag->ops->trst_set(jtag, active);
-		break;
 
 	default:
 		return -EINVAL;
@@ -248,12 +238,9 @@ struct jtag *jtag_alloc(struct device *host, size_t priv_size,
 	if (!ops->status_set || !ops->status_get || !ops->xfer)
 		return NULL;
 
-	jtag = kzalloc(sizeof(*jtag), GFP_KERNEL);
+	jtag = kzalloc(sizeof(*jtag) + priv_size, GFP_KERNEL);
 	if (!jtag)
 		return NULL;
-	jtag->priv = kzalloc(priv_size, GFP_KERNEL);
-	if (!jtag->priv)
-		return NULL;
 
 	jtag->ops = ops;
 	jtag->miscdev.parent = host;
diff --git a/drivers/jtag/jtag.h b/drivers/jtag/jtag.h
new file mode 100644
index 000000000000..b500266cfd61
--- /dev/null
+++ b/drivers/jtag/jtag.h
@@ -0,0 +1,369 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/* Copyright (c) 2018 Mellanox Technologies. All rights reserved. */
+/* Copyright (c) 2018 Oleksandr Shamray <oleksandrs@mellanox.com> */
+/* Copyright (c) 2019 Intel Corporation */
+
+#ifndef __UAPI_LINUX_JTAG_H
+#define __UAPI_LINUX_JTAG_H
+
+#include <linux/types.h>
+#include <linux/ioctl.h>
+
+/*
+ * JTAG_XFER_MODE: JTAG transfer mode. Used to set JTAG controller transfer mode
+ * This is bitmask for feature param in jtag_mode for ioctl JTAG_SIOCMODE
+ */
+#define  JTAG_XFER_MODE 0
+/*
+ * JTAG_CONTROL_MODE: JTAG controller mode. Used to set JTAG controller mode
+ * This is bitmask for feature param in jtag_mode for ioctl JTAG_SIOCMODE
+ */
+#define  JTAG_CONTROL_MODE 1
+/*
+ * JTAG_MASTER_OUTPUT_DISABLE: JTAG master mode output disable, it is used to
+ * enable other devices to own the JTAG bus.
+ * This is bitmask for mode param in jtag_mode for ioctl JTAG_SIOCMODE
+ */
+#define  JTAG_MASTER_OUTPUT_DISABLE 0
+/*
+ * JTAG_MASTER_MODE: JTAG master mode. Used to set JTAG controller master mode
+ * This is bitmask for mode param in jtag_mode for ioctl JTAG_SIOCMODE
+ */
+#define  JTAG_MASTER_MODE 1
+/*
+ * JTAG_XFER_HW_MODE: JTAG hardware mode. Used to set HW drived or bitbang
+ * mode. This is bitmask for mode param in jtag_mode for ioctl JTAG_SIOCMODE
+ */
+#define  JTAG_XFER_HW_MODE 1
+/*
+ * JTAG_XFER_SW_MODE: JTAG software mode. Used to set SW drived or bitbang
+ * mode. This is bitmask for mode param in jtag_mode for ioctl JTAG_SIOCMODE
+ */
+#define  JTAG_XFER_SW_MODE 0
+
+/**
+ * enum jtag_tapstate:
+ *
+ * @JTAG_STATE_TLRESET: JTAG state machine Test Logic Reset state
+ * @JTAG_STATE_IDLE: JTAG state machine IDLE state
+ * @JTAG_STATE_SELECTDR: JTAG state machine SELECT_DR state
+ * @JTAG_STATE_CAPTUREDR: JTAG state machine CAPTURE_DR state
+ * @JTAG_STATE_SHIFTDR: JTAG state machine SHIFT_DR state
+ * @JTAG_STATE_EXIT1DR: JTAG state machine EXIT-1 DR state
+ * @JTAG_STATE_PAUSEDR: JTAG state machine PAUSE_DR state
+ * @JTAG_STATE_EXIT2DR: JTAG state machine EXIT-2 DR state
+ * @JTAG_STATE_UPDATEDR: JTAG state machine UPDATE DR state
+ * @JTAG_STATE_SELECTIR: JTAG state machine SELECT_IR state
+ * @JTAG_STATE_CAPTUREIR: JTAG state machine CAPTURE_IR state
+ * @JTAG_STATE_SHIFTIR: JTAG state machine SHIFT_IR state
+ * @JTAG_STATE_EXIT1IR: JTAG state machine EXIT-1 IR state
+ * @JTAG_STATE_PAUSEIR: JTAG state machine PAUSE_IR state
+ * @JTAG_STATE_EXIT2IR: JTAG state machine EXIT-2 IR state
+ * @JTAG_STATE_UPDATEIR: JTAG state machine UPDATE IR state
+ * @JTAG_STATE_CURRENT: JTAG current state, saved by driver
+ */
+enum jtag_tapstate {
+	JTAG_STATE_TLRESET,
+	JTAG_STATE_IDLE,
+	JTAG_STATE_SELECTDR,
+	JTAG_STATE_CAPTUREDR,
+	JTAG_STATE_SHIFTDR,
+	JTAG_STATE_EXIT1DR,
+	JTAG_STATE_PAUSEDR,
+	JTAG_STATE_EXIT2DR,
+	JTAG_STATE_UPDATEDR,
+	JTAG_STATE_SELECTIR,
+	JTAG_STATE_CAPTUREIR,
+	JTAG_STATE_SHIFTIR,
+	JTAG_STATE_EXIT1IR,
+	JTAG_STATE_PAUSEIR,
+	JTAG_STATE_EXIT2IR,
+	JTAG_STATE_UPDATEIR,
+	JTAG_STATE_CURRENT
+};
+
+/**
+ * enum jtag_reset:
+ *
+ * @JTAG_NO_RESET: JTAG run TAP from current state
+ * @JTAG_FORCE_RESET: JTAG force TAP to reset state
+ */
+enum jtag_reset {
+	JTAG_NO_RESET = 0,
+	JTAG_FORCE_RESET = 1,
+};
+
+/**
+ * enum jtag_xfer_type:
+ *
+ * @JTAG_SIR_XFER: SIR transfer
+ * @JTAG_SDR_XFER: SDR transfer
+ */
+enum jtag_xfer_type {
+	JTAG_SIR_XFER = 0,
+	JTAG_SDR_XFER = 1,
+};
+
+/**
+ * enum jtag_xfer_direction:
+ *
+ * @JTAG_READ_XFER: read transfer
+ * @JTAG_WRITE_XFER: write transfer
+ * @JTAG_READ_WRITE_XFER: read & write transfer
+ */
+enum jtag_xfer_direction {
+	JTAG_READ_XFER = 1,
+	JTAG_WRITE_XFER = 2,
+	JTAG_READ_WRITE_XFER = 3,
+};
+
+/**
+ * struct jtag_tap_state - forces JTAG state machine to go into a TAPC
+ * state
+ *
+ * @reset: 0 - run IDLE/PAUSE from current state
+ *         1 - go through TEST_LOGIC/RESET state before  IDLE/PAUSE
+ * @end: completion flag
+ * @tck: clock counter
+ *
+ * Structure provide interface to JTAG device for JTAG set state execution.
+ */
+struct jtag_tap_state {
+	__u8	reset;
+	__u8	from;
+	__u8	endstate;
+	__u8	tck;
+};
+
+/**
+ * union pad_config - Padding Configuration:
+ *
+ * @type: transfer type
+ * @pre_pad_number: Number of prepadding bits bit[11:0]
+ * @post_pad_number: Number of prepadding bits bit[23:12]
+ * @pad_data : Bit value to be used by pre and post padding bit[24]
+ * @int_value: unsigned int packed padding configuration value bit[32:0]
+ *
+ * Structure provide pre and post padding configuration in a single __u32
+ */
+union pad_config {
+	struct {
+		__u32 pre_pad_number	: 12;
+		__u32 post_pad_number	: 12;
+		__u32 pad_data		: 1;
+		__u32 rsvd		: 7;
+	};
+	__u32 int_value;
+};
+
+/**
+ * struct jtag_xfer - jtag xfer:
+ *
+ * @type: transfer type
+ * @direction: xfer direction
+ * @from: xfer current state
+ * @endstate: xfer end state
+ * @padding: xfer padding
+ * @length: xfer bits length
+ * @tdio : xfer data array
+ *
+ * Structure provide interface to JTAG device for JTAG SDR/SIR xfer execution.
+ */
+struct jtag_xfer {
+	__u8	type;
+	__u8	direction;
+	__u8	from;
+	__u8	endstate;
+	__u32	padding;
+	__u32	length;
+	__u64	tdio;
+};
+
+/**
+ * struct bitbang_packet - jtag bitbang array packet:
+ *
+ * @data:   JTAG Bitbang struct array pointer(input/output)
+ * @length: array size (input)
+ *
+ * Structure provide interface to JTAG device for JTAG bitbang bundle execution
+ */
+struct bitbang_packet {
+	struct tck_bitbang *data;
+	__u32	length;
+} __attribute__((__packed__));
+
+/**
+ * struct jtag_bitbang - jtag bitbang:
+ *
+ * @tms: JTAG TMS
+ * @tdi: JTAG TDI (input)
+ * @tdo: JTAG TDO (output)
+ *
+ * Structure provide interface to JTAG device for JTAG bitbang execution.
+ */
+struct tck_bitbang {
+	__u8	tms;
+	__u8	tdi;
+	__u8	tdo;
+} __attribute__((__packed__));
+
+/**
+ * struct jtag_mode - jtag mode:
+ *
+ * @feature: 0 - JTAG feature setting selector for JTAG controller HW/SW
+ *           1 - JTAG feature setting selector for controller bus master
+ *               mode output (enable / disable).
+ * @mode:    (0 - SW / 1 - HW) for JTAG_XFER_MODE feature(0)
+ *           (0 - output disable / 1 - output enable) for JTAG_CONTROL_MODE
+ *                                                    feature(1)
+ *
+ * Structure provide configuration modes to JTAG device.
+ */
+struct jtag_mode {
+	__u32	feature;
+	__u32	mode;
+};
+
+/* ioctl interface */
+#define __JTAG_IOCTL_MAGIC	0xb2
+
+#define JTAG_SIOCSTATE	_IOW(__JTAG_IOCTL_MAGIC, 0, struct jtag_tap_state)
+#define JTAG_SIOCFREQ	_IOW(__JTAG_IOCTL_MAGIC, 1, unsigned int)
+#define JTAG_GIOCFREQ	_IOR(__JTAG_IOCTL_MAGIC, 2, unsigned int)
+#define JTAG_IOCXFER	_IOWR(__JTAG_IOCTL_MAGIC, 3, struct jtag_xfer)
+#define JTAG_GIOCSTATUS _IOWR(__JTAG_IOCTL_MAGIC, 4, enum jtag_tapstate)
+#define JTAG_SIOCMODE	_IOW(__JTAG_IOCTL_MAGIC, 5, unsigned int)
+#define JTAG_IOCBITBANG	_IOW(__JTAG_IOCTL_MAGIC, 6, unsigned int)
+
+/**
+ * struct tms_cycle - This structure represents a tms cycle state.
+ *
+ * @tmsbits: is the bitwise representation of the needed tms transitions to
+ *           move from one state to another.
+ * @count:   number of jumps needed to move to the needed state.
+ *
+ */
+struct tms_cycle {
+	unsigned char tmsbits;
+	unsigned char count;
+};
+
+/*
+ * This is the complete set TMS cycles for going from any TAP state to any
+ * other TAP state, following a "shortest path" rule.
+ */
+static const struct tms_cycle _tms_cycle_lookup[][16] = {
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* TLR  */{{0x00, 0}, {0x00, 1}, {0x02, 2}, {0x02, 3}, {0x02, 4}, {0x0a, 4},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x0a, 5}, {0x2a, 6}, {0x1a, 5}, {0x06, 3}, {0x06, 4}, {0x06, 5},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x16, 5}, {0x16, 6}, {0x56, 7}, {0x36, 6} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* RTI  */{{0x07, 3}, {0x00, 0}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x05, 4}, {0x15, 5}, {0x0d, 4}, {0x03, 2}, {0x03, 3}, {0x03, 4},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x1b, 5} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SelDR*/{{0x03, 2}, {0x03, 3}, {0x00, 0}, {0x00, 1}, {0x00, 2}, {0x02, 2},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x02, 3}, {0x0a, 4}, {0x06, 3}, {0x01, 1}, {0x01, 2}, {0x01, 3},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x05, 3}, {0x05, 4}, {0x15, 5}, {0x0d, 4} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* CapDR*/{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x00, 0}, {0x00, 1}, {0x01, 1},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x01, 2}, {0x05, 3}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SDR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x00, 0}, {0x01, 1},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x01, 2}, {0x05, 3}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex1DR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x02, 3}, {0x00, 0},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x00, 1}, {0x02, 2}, {0x01, 1}, {0x07, 3}, {0x07, 4}, {0x07, 5},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x17, 5}, {0x17, 6}, {0x57, 7}, {0x37, 6} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* PDR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x01, 2}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x00, 0}, {0x01, 1}, {0x03, 2}, {0x0f, 4}, {0x0f, 5}, {0x0f, 6},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x2f, 6}, {0x2f, 7}, {0xaf, 8}, {0x6f, 7} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex2DR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x00, 1}, {0x02, 2},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x02, 3}, {0x00, 0}, {0x01, 1}, {0x07, 3}, {0x07, 4}, {0x07, 5},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x17, 5}, {0x17, 6}, {0x57, 7}, {0x37, 6} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* UpdDR*/{{0x07, 3}, {0x00, 1}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x05, 4}, {0x15, 5}, {0x00, 0}, {0x03, 2}, {0x03, 3}, {0x03, 4},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x1b, 5} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SelIR*/{{0x01, 1}, {0x01, 2}, {0x05, 3}, {0x05, 4}, {0x05, 5}, {0x15, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x15, 6}, {0x55, 7}, {0x35, 6}, {0x00, 0}, {0x00, 1}, {0x00, 2},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x02, 2}, {0x02, 3}, {0x0a, 4}, {0x06, 3} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* CapIR*/{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x00, 0}, {0x00, 1},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x01, 1}, {0x01, 2}, {0x05, 3}, {0x03, 2} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* SIR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x0f, 5}, {0x00, 0},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x01, 1}, {0x01, 2}, {0x05, 3}, {0x03, 2} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex1IR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x03, 4}, {0x0b, 4},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x0b, 5}, {0x2b, 6}, {0x1b, 5}, {0x07, 3}, {0x07, 4}, {0x02, 3},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x00, 0}, {0x00, 1}, {0x02, 2}, {0x01, 1} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* PIR  */{{0x1f, 5}, {0x03, 3}, {0x07, 3}, {0x07, 4}, {0x07, 5}, {0x17, 5},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x17, 6}, {0x57, 7}, {0x37, 6}, {0x0f, 4}, {0x0f, 5}, {0x01, 2},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x05, 3}, {0x00, 0}, {0x01, 1}, {0x03, 2} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* Ex2IR*/{{0x0f, 4}, {0x01, 2}, {0x03, 2}, {0x03, 3}, {0x03, 4}, {0x0b, 4},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x0b, 5}, {0x2b, 6}, {0x1b, 5}, {0x07, 3}, {0x07, 4}, {0x00, 1},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x02, 2}, {0x02, 3}, {0x00, 0}, {0x01, 1} },
+
+/*	    TLR        RTI        SelDR      CapDR      SDR        Ex1DR*/
+/* UpdIR*/{{0x07, 3}, {0x00, 1}, {0x01, 1}, {0x01, 2}, {0x01, 3}, {0x05, 3},
+/*	    PDR        Ex2DR      UpdDR      SelIR      CapIR      SIR*/
+	    {0x05, 4}, {0x15, 5}, {0x0d, 4}, {0x03, 2}, {0x03, 3}, {0x03, 4},
+/*	    Ex1IR      PIR        Ex2IR      UpdIR*/
+	    {0x0b, 4}, {0x0b, 5}, {0x2b, 6}, {0x00, 0} },
+};
+
+#endif /* __UAPI_LINUX_JTAG_H */
